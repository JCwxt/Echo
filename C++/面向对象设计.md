## 面向对象设计

### 一，基本概念

**面向对象的分析（OOA）：**分析出需求，需要做什么。

**面向对象的设计（OOD）：**根据需求设计出对应的类，类中的数据成员，成员函数，类与类之间的关系，面向对象的设计原则。

**面向对象的编程(OOP)：**根据分析出来的需要，以及设计的类，进行代码实现。

**统一建模语言：UML。**

### 二，类与类之间的关系

#### 1.继承（泛化）

基类会成为派生类的一部分，在语义层面上：A is B ，在类图的画法上：从派生类（A）指向基类（B）的实线空心三角箭头。

继承：先有基类，然后再派生出新的类，即：派生类。

泛化（一般化）：先有派生类，然后将相同的属性抽出来，然后形成基类。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250805174259532.png" alt="image-20250805174259532" style="zoom:67%;" />

#### 2.关联

##### 1.双向关联关系

彼此知道对方的存在，但是彼此并不负责对方的生命周期。

在语义层面上：A has B。

在类图的画法上：A与B之间直接使用实线连接即可。

在代码层面上：使用的是指针或者引用。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250805175020603.png" alt="image-20250805175020603" style="zoom: 80%;" />

##### 2.单向关联关系

A知道B的存在，B不知道A的存在，A并不会负责B的销毁。

**在语义层面上：**A has B

**在代码层面上：**使用的是指针或者引用。

**在类图的画法上：**使用的是从A指向B的实线箭头。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250805175242614.png" alt="image-20250805175242614" style="zoom:80%;" />

#### 3.聚合关系

聚合关系是一种稍微强一点的关联关系，表现为整体与局部的关系，但是整体并不负责局部的销毁。

**在语义层面上：**A has B。

**在代码层面上：**使用指针或者引用。

**在类图的画法上：**从局部指向整体的空心菱形箭头。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250805175541475.png" alt="image-20250805175541475" style="zoom:67%;" />

#### 4.组合关系

组合关系是一种更强的关联关系，表现为整体与局部，并且整体部分会负责局部的销毁。

**在语义层面上：**A has B。

**在代码层面上：**使用的是子对象。

**在类图的画法上：**从局部指向整体的实心菱形箭头。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250805192417740.png" alt="image-20250805192417740" style="zoom:67%;" />

#### 5.依赖关系

依赖关系是两个类之间的一种不确定的关系。这种关系是偶然的，临时的，并非固定的。

**语义上：**A use B

**在代码上：**

- B是A的成员函数参数
- B作为A的成员函数的局部变量或者B作为A的成员函数返回值。
- A的成员函数调用B的静态方法。

**在类图的画法上：**从A指向B的虚线箭头。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250805193234240.png" alt="image-20250805193234240" style="zoom:67%;" />

#### 6.总结

1.继承关系是先有基类然后有派生类，所以是垂直关系，但是其它的四种关系都是水平关系。

2.从耦合程度：依赖<关联<聚合<组合<继承。

3.从语义层面：继承：is ；依赖：use；

​                          关联，聚合，组合：has。

4.从代码层面：关联，聚合，组合体现的是数据成员；依赖：体现在成员函数上；继承：既体现在数据成员，也体现在成员函数。

### 三，面向对象的设计原则

**设计要求：**低耦合，高内聚。

低耦合：强调的是类与类之间的关系，模块与模块之间的关系。

高内聚：强调的是类内部或者模块内部的关系。

#### 1.单一职责原则（SRP）

一个类最好只做一件事情，只有一个引起它变化的原因。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250805193652096.png" alt="image-20250805193652096" style="zoom:67%;" />

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250805193713353.png" alt="image-20250805193713353" style="zoom:67%;" />

#### 2.开闭原则(OCP)

**核心思想：**对抽象编程，而不对具体编程，因为抽象相对稳定。

面对抽象类进行编程，因为抽象类中只是提供了接口，并没有具体的实现，这样当有新的需求发生变更，那么这样抽象类的设计方式更能应对需求变更，也更具备扩展性。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250805193837053.png" alt="image-20250805193837053" style="zoom: 50%;" />

#### 3.里式替换原则(LSP)

**核心思想：**派生类必须能够替换其基类。

派生类可以实现基类的抽象方法，表现为多态。

不能覆盖基类的非抽象方法（不能使用c++中的隐藏）。

派生类可以有自己的个性（c++中的新成员）。

对于里式替换原则而言，派生类要能完全替换基类，但是在c++中存在隐藏，所以为了满足里式替换原则，就不让基类与派生类有同名的非虚函数即可。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250805194031472.png" alt="image-20250805194031472" style="zoom:67%;" />

#### 4.接口分离原则(ISP)

**核心思想：**使用多个小的专门的接口，而不要使用一个大的总接口。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250805194429012.png" alt="image-20250805194429012" style="zoom:67%;" />

Bird作为基类，如果fly这个函数设置在其中那么Crow局部fly的特性没有问题，但是Ostrich也具备了fly特性就有问题了，因此需将fly接口设计小点。

#### 5.依赖倒置原则(DIP)

**核心思想：**面向接口编程，依赖于抽象。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250805194658270.png" alt="image-20250805194658270" style="zoom:67%;" />

<span style=color:red;background:yellow;font-size:20px>在大多数情况下，开闭原则、里氏替换原则、依赖倒置原则会同时出现，开闭原则是目标，里氏替换原则是基础，依赖倒置原则是手段</span> 

#### 6.迪米特原则

也叫最少知识原则，或者最少知道原则。

**核心思想：**降低耦合度。

#### 7.组合复用原则

在复用时要尽量使用组合/聚合关系（关联关系），少用继承。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250805194804376.png" alt="image-20250805194804376" style="zoom: 50%;" />

### 四，设计模式

#### 1.分类

- 创建型模式5种：主要用于创建对象；提供对象创建机制，增加现有代码的灵活性和重用；

- 结构型模式7种：主要用于处理类或对象的组合；解释如何将对象和类组装成更大的结构，同时保持结构的灵活性和高效性；
- 行为型模式11种：主要用于描述对类或对象怎样交互和怎样分配职责；负责有效的沟通和对象之间的责任分配 ；

#### 2.常见设计模式

##### 2.1.简单工厂模式

提供一个工厂类，工厂类根据传入的产品类型创建出产品，当有新的产品时，需要修改工厂类

特点：简单

缺点：

- 1.违反了单一职责原则。

- 2.违反了开放闭合原则。

- 3.违反了依赖倒置原则。

```C++
#include <math.h>
#include <iostream>
#include <string>
#include <memory>

using std::unique_ptr;
using std::string;
using std::cout;
using std::endl;

//抽象类，作为接口使用
class Figure
{
public:
    //纯虚函数
    virtual void display() const = 0;
    virtual double area() const = 0;
    virtual ~Figure(){cout<<"~figure"<<endl;};
};

class Rectangle
: public Figure
{
public:
    Rectangle(double length = 0, double width = 0)
    : _length(length)
    , _width(width)
    {
        cout << "Rectangle(double = 0, double = 0)" << endl;
    }

    void display() const override
    {
        cout << "Rectangle";
    }

    double area() const override
    {
        return _length * _width;
    }

    ~Rectangle()
    {
        cout << "~Rectangle()" << endl;
    }
private:
    double _length;
    double _width;
};

class Circle
: public Figure
{
public:
    Circle(double radius = 0)
    : _radius(radius)
    {
        cout << "Circle(double = 0)" << endl;
    }

    void display() const override
    {
        cout << "Circle";
    }

    double area() const override
    {
        return 3.14 * _radius *_radius;;
    }

    ~Circle()
    {
        cout << "~Circle()" << endl;
    }
private:
    double _radius;
};

class Triangle
: public Figure
{
public:
    Triangle(double a = 0, double b = 0, double c = 0)
    : _a(a)
    , _b(b)
    , _c(c)
    {
        cout << "Triangle(double = 0, double = 0, double = 0)" << endl;
    }

    void display() const override
    {
        cout << "Triangle";
    }

    double area() const override
    {
        //海伦公式
        double tmp = (_a + _b + _c)/2;

        return sqrt(tmp * (tmp - _a) * (tmp - _b) * (tmp - _c));
    }

    ~Triangle()
    {
        cout << "~Triangle()" << endl;
    }
private:
    double _a;
    double _b;
    double _c;
};

void func(Figure *pfig)
{
    pfig->display();
    cout << "的面积 : " << pfig->area() << endl;
}
class factory{
public:
    static Figure *Create(const string name){
        if(name=="Rectangle"){
            Rectangle *prec=new Rectangle(10,20);
            return prec;
        }
        else if(name=="Circle"){
            Circle *pcir=new Circle(10);
            return pcir;
        }
        else if(name=="Triangle"){
            Triangle *ptri=new Triangle(3,4,5);
            return ptri;
        }else{
            return nullptr;
        }
    }
};
int main(int argc, char **argv)
{

    unique_ptr<Figure> prec(factory::Create("Rectangle"));
    func(prec.get());
    unique_ptr<Figure> pcir(factory::Create("Circle"));
    func(pcir.get());
    unique_ptr<Figure> ptri(factory::Create("Triangle"));
    func(ptri.get());

    return 0;
}
```

<img src="C:\Users\34078\Pictures\Screenshots\屏幕截图 2025-08-05 211453.png" style="zoom: 50%;" />

##### 2.2 工厂设计模式

工厂类不在负责产品的创建，而是演变为一个抽象工厂，仅负责具体工厂子类必须实现的接口，同时针对不同的产品提供不同的工厂，即每个工厂对应一种产品，这样新增产品时就不需要修改工厂类，只需添加新的工厂子类。

优点：

- 1.满足了单一职责原则。
- 2.满足了开放闭合原则。
- 3.满足了依赖倒置原则。
- 4.满足了里氏替换原则。

缺点：工厂的数目会随着产品的数目急剧上升。

<img src="C:\Users\34078\Pictures\Screenshots\屏幕截图 2025-08-05 212125.png" style="zoom: 67%;" />

```C++
#include <math.h>
#include <iostream>
#include <string>
#include <memory>

using std::unique_ptr;
using std::string;
using std::cout;
using std::endl;

//抽象类，作为接口使用
class Figure
{
public:
    //纯虚函数
    virtual void display() const = 0;
    virtual double area() const = 0;
    virtual ~Figure(){cout<<"~figure"<<endl;};
};

class Rectangle
: public Figure
{
public:
    Rectangle(double length = 0, double width = 0)
    : _length(length)
    , _width(width)
    {
        cout << "Rectangle(double = 0, double = 0)" << endl;
    }

    void display() const override
    {
        cout << "Rectangle";
    }

    double area() const override
    {
        return _length * _width;
    }

    ~Rectangle()
    {
        cout << "~Rectangle()" << endl;
    }
private:
    double _length;
    double _width;
};

class Circle
: public Figure
{
public:
    Circle(double radius = 0)
    : _radius(radius)
    {
        cout << "Circle(double = 0)" << endl;
    }

    void display() const override
    {
        cout << "Circle";
    }

    double area() const override
    {
        return 3.14 * _radius *_radius;;
    }

    ~Circle()
    {
        cout << "~Circle()" << endl;
    }
private:
    double _radius;
};

class Triangle
: public Figure
{
public:
    Triangle(double a = 0, double b = 0, double c = 0)
    : _a(a)
    , _b(b)
    , _c(c)
    {
        cout << "Triangle(double = 0, double = 0, double = 0)" << endl;
    }

    void display() const override
    {
        cout << "Triangle";
    }

    double area() const override
    {
        //海伦公式
        double tmp = (_a + _b + _c)/2;

        return sqrt(tmp * (tmp - _a) * (tmp - _b) * (tmp - _c));
    }

    ~Triangle()
    {
        cout << "~Triangle()" << endl;
    }
private:
    double _a;
    double _b;
    double _c;
};

void func(Figure *pfig)
{
    pfig->display();
    cout << "的面积 : " << pfig->area() << endl;
}
class factory{
public:
    virtual Figure *Create()=0;
    virtual ~factory(){};
};

class RectangleFactory
:public factory
{
public:
    Figure *Create(){
        Figure *prec=new Rectangle(10,20);
        return prec;
    }

    ~RectangleFactory(){
        cout<<"~RectangleFactory"<<endl;
    }
};
class CircleFactory
:public factory
{
public:
    Figure *Create(){
        Figure *pcir=new Circle(10);
        return pcir;
    }

    ~CircleFactory(){
        cout<<"~CircleFactory"<<endl;
    }
};
class TriangleFactory
:public factory
{
public:
    Figure *Create(){
        Figure *ptri=new Triangle(3,4,5);
        return ptri;
    }

    ~TriangleFactory(){
        cout<<"~TriangleFactory"<<endl;
    }
};
int main(int argc, char **argv)
{

    unique_ptr<factory> rec(new RectangleFactory());
    unique_ptr<Figure> prec(rec->Create());
    func(prec.get());
    unique_ptr<factory> cir(new CircleFactory());
    unique_ptr<Figure> pcir(rec->Create());
    func(prec.get());
    unique_ptr<factory> tri(new TriangleFactory());
    unique_ptr<Figure> ptri(rec->Create());
    func(prec.get());
    return 0;
}
```



##### 2.3 抽象工厂

抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它提供了一个接口，用于创建一系列相关或相互依赖的对象，而无需指定它们具体的类。其核心是围绕一个超级工厂创建其他工厂，每个具体工厂负责生产同一产品族的产品。

------

**抽象工厂模式的核心角色**

1. **抽象工厂（Abstract Factory）**
   定义创建一系列产品的接口，包含多个创建产品的抽象方法（每个方法对应一类产品）。

2. **具体工厂（Concrete Factory）**
   实现抽象工厂的接口，负责生产某一产品族的具体产品（产品族指同一品牌、相互配套的一系列产品）。

3. **抽象产品（Abstract Product）**
   定义某类产品的接口，是具体产品的父类或接口。

4. **具体产品（Concrete Product）**
   实现抽象产品的接口，由具体工厂生产，属于同一产品族。

------

   

**类图：**

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250807222803636.png" alt="image-20250807222803636" style="zoom:67%;" />

**代码实现：**

```C++
#include <iostream>
#include <memory>
using namespace std;
class MainBrand{
public:
    virtual void show()=0;
    virtual ~MainBrand(){ cout<<"MainBrand"<<endl; };
};
class IntelMainBrand:public MainBrand{
public:
    void show(){
        cout<<"Intel主板"<<endl;
    }
    ~IntelMainBrand(){cout<<"IntelMainBrand"<<endl;};
};
class AMDMainBrand:public MainBrand{
public:
    void show(){
        cout<<"AMD主板"<<endl;
    }
    ~AMDMainBrand(){cout<<"~AMDMainBrand"<<endl;};
};
class CPU{
public:
    virtual void show()=0;
    virtual ~CPU(){cout<<"~CPU"<<endl;};
};
class IntelCPU:public CPU{
public:
    void show(){
        cout<<"IntelCPU"<<endl;
    }
    ~IntelCPU(){
        cout<<"~IntelCPU"<<endl;
    }
};
class AMDCPU:public CPU{
public:
    void show(){
        cout<<"AMDCPU"<<endl;
    }
    ~AMDCPU(){
        cout<<"~AMDCPU"<<endl;
    }
};
class AbstractFactory{
public:
    virtual MainBrand * createMainBrand()=0;
    virtual CPU * createCPU()=0;
    virtual ~AbstractFactory(){cout<<"~AbstractFactory"<<endl;};
};
class IntelFactory:public AbstractFactory{
public:
    MainBrand *createMainBrand(){
        cout<<"生产IntelMainBrand"<<endl;
        return new IntelMainBrand();
    }
    CPU* createCPU(){
        cout<<"生产IntelCPU"<<endl;
        return new IntelCPU();
    }
    ~IntelFactory(){
        cout<<"~IntelFactory"<<endl;
    }
};
class AMDFactory:public AbstractFactory{
public:
    MainBrand *createMainBrand(){
        cout<<"生产AMDMainBrand"<<endl;
        return new AMDMainBrand();
    }
    CPU * createCPU(){
        cout<<"生产AMDCPU"<<endl;
        return new AMDCPU();
    }
    ~AMDFactory(){
        cout<<"~AMDFactory"<<endl;
    }
};
void test(){
    unique_ptr<AbstractFactory> Intel(new IntelFactory());
    MainBrand *Intelmainbrand=Intel->createMainBrand();
    CPU *Intelcpu=Intel->createCPU();
    Intelmainbrand->show();
    Intelcpu->show();
    delete Intelmainbrand;
    delete Intelcpu;

    unique_ptr<AbstractFactory> AMD(new AMDFactory());

    MainBrand *AMDmainbrand=AMD->createMainBrand();
    CPU *AMDcpu=AMD->createCPU();
    AMDmainbrand->show();
    AMDcpu->show();
    delete AMDmainbrand;
    delete AMDcpu;
}

int main()
{
 test();
 return 0;
}
```

**优点：**

- 抽象工厂模式隔离了具体类的生成，使得客户端并不需要知道什么被创建；
- 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一产品族中的对象；
- 增加新的产品族很方便（生成新的具体工厂），无需修改已有系统代码，符合开闭原则；

**缺点：**

增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。

**使用场景：**

- 用户无需关心对象的创建过程，将对象的创建和使用解耦；
- 产品等级结构稳定，在设计完成之后不会向系统中增加新的产品等级结构或者删除已有的产品等级结构；
- 系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使用户能够动态改变产品族，也可以很方便的增加新的产品族。

##### 2.4 观察者模式

**特点：**<font color='red'>定义对象的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。</font>

**优点：**

- **解耦对象关系：**被观察者和观察者之间通过抽象接口交互，减少了直接依赖，便于代码维护和复用。
- **灵活的事件响应：**可以动态添加或移除观察者，适应不同场景下的事件处理需求。
- **支持广播通信：**被观察者的状态变化可以高效地通知所有相关观察者，无需逐个处理，提高了系统的响应效率。

**缺点：**

- 若观察者数量过多或更新逻辑复杂，被观察者状态变化时可能导致大量同步更新，影响性能。
- 如果观察者和被观察者之间存在循环依赖，可能导致无限循环的通知，导致系统崩溃。
- 通知顺序不明确，观察者模式未定义通知的顺序，若业务逻辑依赖特定的更新顺序，需要额外设计控制机制。

**应用场景：**

- 一个抽象模型有两个方面，其中一个方面依赖于另外一个方面。将这两个方面分别封装在独立的对象中使他们可以各自独立的改变和复用。

- 一个对象的改变将导致其它一个或多个对象发生改变，而不知道具体有多少个对象将发生改变，可以降低对象之间的耦合度。

- 一个对象必须通知其它对象，而不知道这些对象是谁。

  

**类图：**

![image-20250807200650498](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250807200650498.png)

**实现代码**：

```C++
#include <iostream>
#include <list>
#include <memory>
using namespace std;
class Observer{
public:
    virtual void updata(double t,double s,double uv)=0;
    ~Observer(){cout<<"~Observer"<<endl;};
};
class ObserverA:public Observer{
public:
    void updata(double t,double s,double uv){
       
        cout<<"ObserverA,今天的天气如下:"<<endl;
        cout<<"温度:"<<t<<" "<<"湿度:"<<s<<" "<<"紫外线强度:"<<uv<<endl;
    }
    ~ObserverA(){
        cout<<"~ObserverA"<<endl;
    }
};

class ObserverB:public Observer{
public:
    void updata(double t,double s,double uv){
        cout<<"ObserverB,今天的天气如下:"<<endl;
        cout<<"温度:"<<t<<" "<<"湿度:"<<s<<" "<<"紫外线强度:"<<uv<<endl;
    }
    ~ObserverB(){
        cout<<"~ObserverB"<<endl;
    }
};
class Subject{
public:
    virtual void attach(Observer *o)=0;
    virtual void detach(Observer *o)=0;
    virtual void notify()=0;
    virtual ~Subject(){cout<<"~Subject"<<endl;};
};
class Wether:public Subject{
public:
    Wether(double t,double h,double u)
    :temperature(t),humidity(h),uv(u)
    {

    }
    void attach(Observer *o){
        if(o){
            ObList.push_back(o);
        }
    }
    void detach(Observer *o){
        if(o){
            ObList.remove(o);
        }
    }
    void notify(){
        for(auto &it:ObList){
            it->updata(temperature,humidity,uv);
        }
    }
    void setWether(double t,double h,double u){
        temperature=t;
        humidity=h;
        uv=u;
    }
    void getWether(){
        cout<<"当前天气:"<<endl;
        cout<<"温度:"<<temperature<<endl
            <<"湿度:"<<humidity<<endl
            <<"紫外线强度:"<<uv<<endl;
    }
private:
    list<Observer *> ObList;
    double temperature;
    double humidity;
    double uv;
};
void test(){
    //创建观察者对象
    unique_ptr<Observer> oba(new ObserverA());
    unique_ptr<Observer> obb(new ObserverB());
    //创建主题对象
    unique_ptr<Wether> wether(new Wether(36.9,89,2000));
    //将观察者添加到主题
    wether->attach(oba.get());
    wether->attach(obb.get());

    //通知所有观察者
    wether->notify();
    cout<<endl;
    //修改状态
    wether->setWether(45,70,5000);
    wether->notify();

    cout<<endl;
    //取消关注
    wether->detach(obb.get());
    //修改状态
    wether->setWether(40,80,3888);
    wether->notify();

    cout<<endl;
    wether->getWether();
}

int main()
{
 test();
 return 0;
}


```

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250807195131293.png" alt="image-20250807195131293" style="zoom:67%;" />

##### 2.5 策略模式

策略模式是一种行为型设计模式，它定义了一系列算法（或行为），并将每个算法封装起来，使它们可以相互替换。策略模式让算法的变化独立于使用算法的客户端，从而实现灵活的行为切换。

**特点：**

- 将一组相关的算法（策略）封装在独立的类中，每个类实现一个具体的算法，且所有策略遵循相同的接口。

- 客户端可以在运行时根据需求动态选择或切换不同的策略，无需修改原有的代码。

**优点：**

- 基于上下文和算法类的封装，方便管理和调度一系列算法策略
- 支持灵活的替换算法策略，代码的可读性和扩展性很强
- 算法被封装以后，可以独立地被多个客户端和上下文复用
- 避免了if-else条件语句的大量使用

**缺点：**

- 使类和对象的数量变得很多，增加了系统的复杂性。
- 如果策略被划分的过于细化，会导致过多设计，不易于代码的理解。
- 代码涉及多个对象的创建和销毁，性能开销增大，大量使用会引起性能问题。

**使用场景：**

- 算法的多样性和可切换行，比如：排序算法，将不同的排序算法（冒泡排序、快速排序、插入排序）封装成具体的策略类。再比如：支付方式：电商系统中，用户可以选择不同的支付方式，如：支付宝、微信、银行卡，将每一种支付方式封装成一个具体的策略类；
- 行为的变化和扩展，比如游戏角色行为，游戏开发中，角色可能有多种行为，如：攻击、防御、移动等，不同的角色可能有不同的行为策略。

**类图：**

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250807202840619.png" alt="image-20250807202840619" style="zoom:67%;" />

**代码实现：**

```C++
#include <iostream>
#include <memory>
using namespace std;
class Startegy{
public:
    virtual void execute()=0;
    virtual ~Startegy(){}
};
class StartegyA:public Startegy{
public:
    void execute(){
        cout<<"执行A计划"<<endl;
    }
    ~StartegyA(){
        cout<<"~StartegyA"<<endl;
    }
};
class StartegyB:public Startegy{
public:
    void execute(){
        cout<<"执行B计划"<<endl;
    }
    ~StartegyB(){
        cout<<"~StartegyB"<<endl;
    }
};
class Context{
public:
    void setStrategy(Startegy *s){
        if(s){
            _pstrategy=s;
        }
    }
    void executeStrategy(){
        _pstrategy->execute();
    }
private:
    Startegy * _pstrategy;
};
void test(){
    unique_ptr<Startegy> sa(new StartegyA());
    unique_ptr<Startegy> sb(new StartegyB());

    unique_ptr<Context> c(new Context());
    c->setStrategy(sa.get());
    c->executeStrategy();
    c->setStrategy(sb.get());
    c->executeStrategy();
}

int main()
{
 test();
 return 0;
}
```

![image-20250807202953046](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250807202953046.png)

##### 2.6 装饰器模式

装饰器模式是一种结构型设计模式，允许不改变已有对象的代码情况下，动态地给对象添加新的行为和责任。

1. **抽象组件（Component）**：定义了被装饰对象和装饰器的共同接口
2. **具体组件（Concrete Component）**：实现抽象组件的原始对象，是被装饰的目标
3. **抽象装饰器（Decorator）**：实现抽象组件接口，并包含一个指向具体组件的引用
4. **具体装饰器（Concrete Decorator）**：扩展抽象装饰器，添加具体的新功能

**优点：**

- 可以动态地添加或删除对象的功能，无需修改原有的代码；
- 不影响现有对象的结构，符合开闭原则；
- 可以灵活地扩展原有对象的功能；
- 可以使用多个装饰器对象来组合多种功能；
- 使得代码可以根据需要轻松地添加或移除功能。

**缺点：**

- 使系统中增加额外的类变量；
- 装饰器对象与原始对象之间的关系过于复杂，降低代码可读性。

**使用场景：**

- 当需要动态地给对象添加或移除功能时
- 当不能通过继承来扩展功能（如 final 类）时
- 当需要组合多个功能，而使用继承会导致类数量急剧增加时

常见应用包括：图形用户界面：在UI框架中，装饰器可以为组件添加滚动条、边框、阴影等装饰效果；日志系统：日志系统中可以使用装饰器来为日志添加时间戳、格式化输出等功能。

**类图：**

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250807211143224.png" alt="image-20250807211143224" style="zoom: 50%;" />



**代码实现：**

```C++
#include <iostream>
#include <memory>
using namespace std;
//抽象组件：饮料
class Beverage{
public:
    string description="未知饮料";
    virtual string getDescription(){
        return description;
    }
    virtual double cost()=0;
    virtual ~Beverage(){cout<<"~Beverage"<<endl;}
};
//具体组件
class Espresso:public Beverage{
public:
    Espresso(){
        description="浓缩咖啡";
    }
    double cost() override{
        return 19.9;
    }
};

class Houseblend:public Beverage{
public:
    Houseblend(){
        description="Houseblend 咖啡";
    }
    double cost() override{
        return 39.9;
    }
};
//抽象装饰器 配料
class Decorator:public Beverage{
public:
    virtual string getDescription()=0;
    virtual ~Decorator(){cout<<"~Decorator"<<endl;};
};

//具体装饰器 牛奶
class Milk :public Decorator{
public:
    Milk(Beverage *bev)
    :beverage(bev){

    }

    string getDescription(){
        return beverage->getDescription()+",牛奶";
    }
    double cost() override{
        return 3.99+beverage->cost();
    }
    ~Milk(){
        cout<<"~Milk";
    }
private:
    Beverage *beverage;
};
class Mocha:public Decorator{
public:
    Mocha(Beverage *bev)
    :beverage(bev)
    {

    }
    string getDescription() override{
        return beverage->getDescription()+",摩卡";
    }
    double cost() override{
        return beverage->cost()+2.99;
    }
    ~Mocha(){
        cout<<"~Mocha"<<endl;
    }
private:
    Beverage *beverage;
};
void test(){
    unique_ptr<Beverage> bev(new Espresso());
    cout<<bev->getDescription()<<endl;
    cout<< bev->cost()<<endl;

    unique_ptr<Beverage> bev2(new Houseblend());

    unique_ptr<Milk> milk(new Milk(bev.get()));
    cout<<milk->getDescription()<<endl;
    cout<<milk->cost()<<endl;
    unique_ptr<Mocha> mocha(new Mocha(bev2.get()));
    cout<<mocha->getDescription()<<endl;
    cout<<mocha->cost()<<endl;
}

int main()
{
 test();
 return 0;
}
```

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250807212153510.png" alt="image-20250807212153510" style="zoom:67%;" />

##### 2.7 模板方法模式

模板方法模式（Template Method Pattern）是一种行为型设计模式，它定义一个操作中的**算法骨架**，将一些步骤延迟到子类中实现。核心思想是：**父类定框架，子类填细节**，从而在不改变算法结构的前提下，让子类重写特定步骤以适应不同需求。

**优点**：

- **代码复用**：将公共流程（如烧水、倒杯）放在父类，减少重复代码。
- **控制反转**：父类控制流程，子类只负责具体实现，符合 “开闭原则”（扩展新饮品只需新增子类）。
- **流程固定**：确保算法结构一致，避免子类随意修改核心流程。

**缺点**：

- 父类中添加新的抽象方法时，所有子类都需修改，增加维护成本。
- 子类执行结果影响父类，可能引入 “反向依赖”。

**适用场景：**

- 多个类的算法流程大部分相同，仅少数步骤有差异（如框架中的生命周期方法）。

- 需要控制子类的执行流程，确保核心步骤不变（如模板引擎、测试框架）。

- 重构时，将重复的流程提取到父类，用子类实现差异化步骤。

**类图：**

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250808222131949.png" alt="image-20250808222131949" style="zoom:50%;" />

```C++
#include <iostream>
#include <memory>
using namespace std;
class Beverage{
public:
    void prepareRecipe(){
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }
    virtual  ~Beverage(){
        cout<<"~Beverage"<<endl;
    }
protected:
    virtual void addCondiments()=0;
    virtual void brew()=0;

    void boilWater(){
        cout<<"烧开水"<<endl;
    }
    void pourInCup(){
        cout<<"将开水倒入杯子"<<endl;
    } 
};
class Coffee:public Beverage{
public:
    void brew() override{
        cout<<"用沸水冲泡咖啡粉"<<endl;
    }
    void addCondiments() override{
        cout<<"加牛奶和糖"<<endl;
    }
    ~Coffee(){
        cout<<"~Coffee"<<endl;
    }
};
class Tea:public Beverage{
public:
    void brew() override{
        cout<<"用沸水冲泡茶叶"<<endl;
    }
    void addCondiments() override{
        cout<<"什么也不加"<<endl;
    }
    ~Tea(){
        cout<<"~Tea"<<endl;
    }
};
void test(){
    unique_ptr<Beverage> bev1(new Coffee());
    unique_ptr<Beverage> bev2(new Tea());

    cout<<"泡咖啡:"<<endl;
    bev1->prepareRecipe();//调用模板方法
    cout<<"============="<<endl;
    cout<<"泡茶:"<<endl;
    bev2->prepareRecipe();

}

int main()
{
 test();
 return 0;
}
```

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250808222003948.png" alt="image-20250808222003948" style="zoom:67%;" />

##### 2.8 职责链模式

职责链模式是一种行为型设计模式，其核心思想是构建一个对象链，让请求在链中依次传递，直到有一个对象能够处理该请求为止。

**职责链模式的核心角色**

1. **抽象处理者（Handler）**
   定义处理请求的接口，包含一个指向 “下一个处理者” 的引用，以及处理请求的抽象方法。

2. **具体处理者（Concrete Handler）**
   实现抽象处理者的接口，判断自身是否能处理请求：

   - 若能处理，则直接处理；
   - 若不能处理，则将请求传递给链中的下一个处理者。

3. **请求（Request）**
   包含需要处理的信息（如请求类型、内容、级别等），供处理者判断是否能处理。

**职责链模式的运行流程**

1. **构建链条**：将具体处理者按顺序连接（如 “组长→部门经理→总经理”）。
2. **发起请求**：请求从链的第一个处理者开始传递。
3. **处理或传递**：每个处理者判断是否能处理请求，能处理则直接处理，否则传递给下一个处理者。
4. **终止条件**：请求被处理，或到达链的末端仍无人处理。

**优点：**

- 可以实现发送者和接收者的解耦；
- 灵活性强，可以修改职责链中的结构和顺序；
- 扩展性，可以在最小改动的情况下添加新的处理器；
- 处理器可以在不同的职责链中重复使用。

**缺点：**

- 对请求的处理可能覆盖不全，导致bug的产生；
- 请求的处理过程十分冗长，请求传递涉及多个对象，性能开销大；
- 责任链需要被一直维护和管理。

**应用场景：**

- 命令处理器：比如在游戏或GUI应用中，用户可以发送各种操作命令，如“播放音乐”、“关闭窗口”，而具体执行过程由一系列处理器完成；
- 日志记录器：将不同严重等级的日志交给不同的处理器去打印；
- Web服务开发：在Web服务中，对请求进行校验和过滤，如权限验证、数据校验等；
- 权限控制：在用户权限管理中，可以根据角色的不同职责分配不同的权限验证步骤；
- 消息路由：在网络通信中，将不同类型的消息分别发送给不同的处理程序；

**类图：**

<img src="C:\Users\34078\Pictures\Screenshots\屏幕截图 2025-08-07 220404.png" style="zoom:67%;" />

**代码实现：**


```c++
#include <iostream>
#include <memory>
using namespace std;
class RaiseRequest{
private:
    string _name;
    int _salary;
public:
    RaiseRequest(string n,int s)
    :_name(n),_salary(s)
    {

    }
    string getName() const{
        return _name;
    }
    int getSalary() const{
        return _salary;
    }
    ~RaiseRequest(){
        cout<<"~RaiseRequest"<<endl;
    }
};

class SalaryApprover{
private:
    SalaryApprover *_pNextchain;
public:
    void setNextchain(SalaryApprover * sa){
        _pNextchain=sa;
    }
    virtual void processRequest(const RaiseRequest &)=0;
    virtual ~SalaryApprover(){cout<<"~SalaryApprover"<<endl;};
protected:
    void sendRequestToNextHandler(const RaiseRequest &r){
        if(_pNextchain!=nullptr){
            _pNextchain->processRequest(r);
        }else{
            cout<<r.getName()<<"的加薪要求："<<r.getSalary()<<"元"
                <<"无人处理"<<endl;
        }
    }
};
class DepartmentManager:public SalaryApprover{
public:
    void  processRequest(const RaiseRequest &r) override{
        if(r.getSalary()<=1000){
            cout<<r.getName()<<"的加薪要求："<<r.getSalary()<<"元"
                <<"被部门经理通过"<<endl;
        }else{
            sendRequestToNextHandler(r);
        }
    }
    ~DepartmentManager(){
        cout<<"~DepartmentManager"<<endl;
    }
};
class CTO:public SalaryApprover{
public:
    void processRequest(const RaiseRequest &r) override{
        if(r.getSalary()<=5000){
            cout<<r.getName()<<"的加薪要求："<<r.getSalary()<<"元"
                <<"被CTO通过"<<endl;
        }else{
            sendRequestToNextHandler(r);
        }
    }
};
class GeneralManager:public SalaryApprover{
public:
    void processRequest(const RaiseRequest &r) override{
        if(r.getSalary()<=10000){
            cout<<r.getName()<<"的加薪要求："<<r.getSalary()<<"元"
                <<"被总经理通过"<<endl;
        }else{
            sendRequestToNextHandler(r);
        }
    }
};
void test(){
    unique_ptr<SalaryApprover> pdm(new DepartmentManager());
    unique_ptr<SalaryApprover> pcto(new CTO());
    unique_ptr<SalaryApprover> pgm(new GeneralManager());
    pdm->setNextchain(pcto.get());
    pcto->setNextchain(pgm.get());
    pgm->setNextchain(nullptr);
    
    RaiseRequest zs("张三",1000);
    RaiseRequest ls("李四",10000);
    RaiseRequest ww("王五",100000);

    pdm->processRequest(zs);
    pdm->processRequest(ls);
    pdm->processRequest(ww);
}

int main()
{
 test();
 return 0;
}
```

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250807220902677.png" alt="image-20250807220902677" style="zoom:67%;" />
