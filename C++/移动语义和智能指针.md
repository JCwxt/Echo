# 移动语义和智能指针

移动语义相对于拷贝，复制语义而言的

复制语义就是每次都去执行复制操作

移动语义就是移交控制权，移交所有权。

#### 右值引用

**右值引用**主要是为了去解决移动语义时存在的相关问题，需要精准识别出具有右值性质的对象，进行控制权的移交而不是复制。

右值引用不可以绑定左值，只可以绑定右值。

```C++
	//非const左值引用不能绑定右值
	int & r1 = a;
	int & r2 = 1; //error

 //const左值引用既可以绑定左值，又可以绑定右值
	const int & r3 = 1;
	const int & r4 = a;

	//右值引用只能绑定右值
	int && r_ref = 10;
	int && r_ref2 = a; //error
```

返回的右值引用究竟是左值还是右值，取决于这个引用变量本身是否有名称，有名称便是左值，可以取地址，没有名称便是右值，不可以取地址

```C++
int number=10;
int &&func(){
    return std::move(number);
}
void test(){
    int &&ref1=func();
    cout<<&ref1<<endl;//绑定了一个右值，但是可以取地址，说明本身是一个左值
   //cout<<&func()<<endl;error 返回值是一个右值不可以取地址
}

```

无论是左值引用还是右值引用，那么均不可以绑定临时变量，临时对象。

```C++
int &&func2(){
    int a=1,b=2;
    return a+b;//返回一个临时变量
}
void test(){
    int &&ref=func2();//后续对于ref的操作都是未定义行为
    cout<<&ref<<endl;//0
}
```

#### std::move()

其本质就是一个类型转换，显示将一个左值转换为一个右值。

```C++
int number=10;
int &&func(){
    return number;//error 右值引用无法绑定左值
    return std::move(number);//将number转换为右值
}
```



#### 移动构造函数

```C++
String s=String(hello);
```

再之前面对上述代码的场景，我们都是先通过构造函数创建一个临时对象，再通过拷贝构造函数，进行深拷贝给s赋值。在此过程中会创建一个临时的堆空间，造成资源的浪费。

<img src="C:\Users\34078\Pictures\Screenshots\屏幕截图 2025-07-24 200015.png" style="zoom:50%;" />

**思考：如何只申请一次堆空间实现上述的代码？**

  引入移动构造函数后，可解决这一问题。让创建的对象也去指向临时对象申请堆空间，但是不释放临时对象申请的堆空间，让临时对象指向nullptr。

```C++
String (String &&rhs)
:_pstr(rhs._pstr)
{
    cout<<"String (String &&rhs)"<<endl;
    rhs._pstr=nullptr;
}
```

![image-20250724201616934](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250724201616934.png)

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250724201752710.png" alt="image-20250724201752710" style="zoom:50%;" />

**移动构造函数的特点：**

1.如果没有显式定义构造函数、拷贝构造、赋值运算符函数、析构函数，编译器会自动生成移动构造，**对右值的复制会调用移动构造。**

2.如果显式定义了拷贝构造，而没有显式定义移动构造，那么对右值的复制会调用拷贝构造。

3.如果显式定义了拷贝构造和移动构造，那么对右值的复制会调用移动构造。

**<font color='red'>总结：</font>**如果显式定义了拷贝构造和移动构造，利用一个已存在的对象创建一个新对象时，会先尝试调用移动构造，如果这个对象是右值，就使用移动构造函数创建出新对象，如果这个对象是左值，移动构造使用不了，就会调用拷贝构造。

------

如果函数的返回值是一个全局对象，那么会优先选择调用拷贝构造函数。

如果函数的返回值是一个局部对象，那么会优先选择调用移动构造函数。

```C++
String globalstr("helloworld");
String fun1(){
    return globalstr;
}
String fun2(){
    String localstr("helloC++");
    return localstr;
}
```

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250724202623785.png" alt="image-20250724202623785" style="zoom: 67%;" />

#### 移动赋值运算函数

```C++
String s1("hello C++");
cout<<s1<<endl;
cout<<"==================="<<endl;
s1=String("hello python");
cout<<s1<<endl;
```

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250724204058526.png" alt="image-20250724204058526" style="zoom:67%;" />

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250724204856458.png" alt="image-20250724204856458" style="zoom:50%;" />

和刚刚的上述场景一样，都会创建一个临时对象和申请一个堆空间。

```C++
String &operator=(String &&rhs)
    {
        cout<<"String &operatror=(String &&rhs)"<<endl;
        if(this!=&rhs){
            delete [] _pstr;
            _pstr=rhs._pstr;
            rhs._pstr=nullptr;
        }
        return *this;
    }
```

<img src="C:\Users\34078\Pictures\Screenshots\屏幕截图 2025-07-24 205251.png" style="zoom:50%;" />

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250724205451524.png" alt="image-20250724205451524" style="zoom: 50%;" />

**思考：为什么在移动赋值运算符函数中还要进行自赋值判断？**

因为c++11之后引入了std::move，可以将一个左值进行强制类型转换，转换过之后那么便可以绕过编译器的检查机制，可以走移动语义。

**移动赋值函数的特点：**

1.如果没有显式定义构造函数、拷贝构造、赋值运算符函数、析构函数，编译器会自动生成移动赋值函数。使用右值的内容进行赋值会调用移动赋值函数。

2.如果显式定义了赋值运算符函数，而没有显式定义移动赋值函数，那么使用右值的内容进行赋值会调用赋值运算符函数。

3.如果显式定义了移动赋值函数和赋值运算符函数，那么使用右值的内容进行赋值会调用移动赋值函数。

#### RAII技术

**RAII技术的特征：**

- 在构造函数中托管资源
- 在析构函数中释放资源
- 一般不允许复制和赋值的方法
- 提供若干访问资源的方法

对象语义：不允许复制和赋值

值语义：允许复制和赋值

```C++
int a=10,b=20;
b=a;
a=30;
int c=a;
```

**思考：如果希望某个对象具有对象语义，不具备值语义，应该怎么做？**

1. 将拷贝构造函数与赋值运算符函数设置为私有的

2. 将拷贝构造函数与赋值运算符函数delete

3. 使用继承的思想，将基类的拷贝构造函数与赋值运算符函数删除（或设为私有），让派生类继承基类。

**RAII技术的实现**

```C++
#include <iostream>
#include <string.h>
using namespace std;
template<class T>
class RAII{
public:
    RAII(T *data)
    :_data(data)
    {
        cout<<"RAII(T *data)"<<endl;
    }

    ~RAII(){
        cout<<"~RAII()"<<endl;
        if(_data){
            delete  _data;
            _data=nullptr;
        }
    }

    T *getdata() const{
        return _data;
    }

    T *operator->(){
        return _data;
    }

    T &operator*(){
        return *_data;
    }
    
    void setData(T *data){
        if(_data){
            delete _data;
            _data=nullptr;
        }
        _data=data;
    }

private:
    RAII(const RAII &rhs)=delete;
    RAII &operator=(const RAII &rhs)=delete;
    T *_data;
};
class Computer{
public:
    Computer(const char * brand,const int price)
    :_brand(new char[strlen(brand)+1]())
    ,_price(price)
    {
       strcpy(_brand,brand);
       cout<<"Computer(char,int)"<<endl;
    }

    void print(){
        cout<<"brand:"<<_brand<<" ,"<<"price"<<_price<<endl;
    }
    ~Computer(){
        cout<<"~Computer()"<<endl;
        if(_brand){
            delete [] _brand;
            _brand=nullptr;
        }
    }
private:
    char *_brand;
    int _price;
};
void test(){
    Computer *c=new Computer("Apple",12000);
    RAII<Computer> raii(c);
    raii->print();
    (*raii).print();
}

int main()
{
 test();
 return 0;
}

```

![image-20250727162500889](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250727162500889.png)

但是不可以将一个原生指针交给两个raii对象来管理，因为此时会释放同一个堆空间两次。

```C++
Computer *c=new Computer("Apple",12000);
RAII<Computer> raii(c);
RAII<Computer> raii2(c);
```

![image-20250727165547310](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250727165547310.png)

#### 智能指针

c++11提供了以下几种智能指针，位于头文件&lt;memory&gt;，它们都是类模板。

```C++
//std::auto_ptr         c++0x

//std::unique_ptr    c++11

//std::shared_ptr     c++11

//std::weak_ptr        c++11
```

##### auto_ptr的使用

auto_ptr是最简单的智能指针，使用上存在缺陷，已经被C++17弃用了。

auto_ptr是有复制、赋值函数的。



``` c++
void test0(){
    int * pInt = new int(10);
    //创建auto_ptr对象接管资源
    auto_ptr<int> ap(pInt);
    cout << "*pInt:" << *pInt << endl;
    cout << "*ap:" << *ap << endl;
}
```

尽管会有warning提示，代码仍可通过。发现不用对pInt进行delete，也没有内存泄露。



auto_ptr可以进行复制，但是存在隐患

``` c++
    auto_ptr<int> ap2(ap);
    cout << "*ap2:" << *ap2 << endl; //ok
    cout << "*ap:" << *ap << endl;  
```

当ap2复制了ap后，对ap2管理的资源进行访问没有问题，但是对ap解引用会导致段错误。

通过阅读源码的实现，ap的指针被置为了空指针。



``` c++
template <class _Tp> 
class auto_ptr {
public:
    //拷贝构造
   auto_ptr(auto_ptr& __a) __STL_NOTHROW 
   //ap2的_M_ptr 被赋值为 ap调用release函数的返回值
   : _M_ptr(__a.release()) 
   {}

    //ap调用release函数
   _Tp* release() __STL_NOTHROW 
   {
     //用局部的指针__tmp接管ap的指针所指向的资源
    _Tp* __tmp = _M_ptr;
    _M_ptr = nullptr; //将ap底层的指针设为空指针
    return __tmp;//返回的就是原本ap管理的资源的地址
  }
    
private:
  _Tp* _M_ptr;
};
```

也就是说，`auto_ptr<int> ap2(ap)； `这一步表面上执行了拷贝操作，但是底层已经将右操作数ap所托管的堆空间的控制权交给了新对象ap2，并且将ap底层的指针数据成员置空，该拷贝操作存在隐患，所以auto_ptr被弃用了。

##### unique_ptr的使用（重要）

unique_ptr对auto_ptr进行了改进。

**特点1：不允许复制或者赋值**

具备对象语义。

**特点2：独享所有权的智能指针**

``` c++
void test0(){
    unique_ptr<int> up(new int(10));
    cout << "*up:" << *up << endl;
    cout << "up.get(): " << up.get() << endl;

    cout << endl;
    //独享所有权的智能指针，对托管的空间独立拥有
    //拷贝构造已经被删除
    unique_ptr<int> up2 = up;//复制操作 error
    
    //赋值运算符函数也被删除
    unique_ptr<int> up3(new int(20));
    up3 = up;//赋值操作 error
}
```

将auto_ptr的缺陷摒弃了，具有对象语义，语法层面不允许复制、赋值。



**特点3：作为容器元素**

要利用**移动语义**的特点，可以直接传递右值属性的unique_ptr作为容器的元素。如果传入左值形态的unique_ptr，会进行复制操作，而unique_ptr是不能复制的。

构建右值的方式有

1、std::move的方式

2、可以直接使用unique_ptr的构造函数，创建匿名对象（临时对象），构建右值

``` c++
	vector<unique_ptr<Point>> vec;
    unique_ptr<Point> up4(new Point(10,20));
    //up4是一个左值
    //将up4这个对象作为参数传给了push_back函数，会调用拷贝构造
    //但是unique_ptr的拷贝构造已经删除了
    //所以这样写会报错
    vec.push_back(up4);  //error
    
    vec.push_back(std::move(up4));  //ok
    vec.push_back(unique_ptr<Point>(new Point(1,3))); //ok
```

> 说明：根据我们对vector的了解，vector的元素一定在堆上，而up4是在栈上的智能指针对象，这里是发生了复制吗？
>
> 1.并不是复制，unique_ptr的拷贝构造是被删除的。
>
> 2.这里实际上要理解为移交管理权，up4不再拥有(10,20)这个Point对象的管理权，而是将管理权交给了vector中的一个新元素，这个新元素便是一个unique_ptr<Point>对象，它存储在vector的堆内存中。
>
> ``` c++
> up4->print(); //error
> vec[0]->print(); //ok
> ```

##### shared_ptr的使用（重要）

智能指针独享资源的控制权固然是一种需求，但有些场景下也需要允许共享控制权。

shared_ptr就是共享所有权的智能指针，可以进行复制或赋值，但复制或赋值时，并不是真正拷贝了被管理的对象，而只是将引用计数加1了。即shared_ptr引入了引用计数，其思想与COW技术类似，又称为是强引用的智能指针。



**特征1：共享所有权的智能指针**

可以使用**引用计数**记录对象的个数。

**特征2：可以进行复制或者赋值**

表明具备值语义。

**特征3：也可以作为容器的元素**

作为容器元素的时候，即可以传递左值，也可以传递右值。（区别于unique_ptr只能传右值）

**特征4：也具备移动语义**

表明也有移动构造函数与移动赋值函数。



``` c++
	shared_ptr<int> sp(new int(10));
    cout << "sp.use_count(): " << sp.use_count() << endl;

    cout << endl;
    cout << "执行复制操作" << endl;
    shared_ptr<int> sp2 = sp;
    cout << "sp.use_count(): " << sp.use_count() << endl;
    cout << "sp2.use_count(): " << sp2.use_count() << endl;

    cout << endl;
    cout << "再创建一个对象sp3" << endl;
    shared_ptr<int> sp3(new int(30));
    cout << "sp.use_count(): " << sp.use_count() << endl;
    cout << "sp2.use_count(): " << sp2.use_count() << endl;
    cout << "sp3.use_count(): " << sp3.use_count() << endl;

    cout << endl;
    cout << "执行赋值操作" << endl;
    sp3 = sp;
    cout << "sp.use_count(): " << sp.use_count() << endl;
    cout << "sp2.use_count(): " << sp2.use_count() << endl;
    cout << "sp3.use_count(): " << sp3.use_count() << endl;

	cout << endl;
	cout << "作为容器元素" << endl;
	vector<shared_ptr<int>> vec;
	vec.push_back(sp);
	vec.push_back(std::move(sp2));
	vec.push_back(shared_ptr<int>(new int(300)));
```

##### shared_ptr的循环引用

shared_ptr还存在一个问题 —— 循环引用问题。

> 我们建立一个Parent和Child类的一个结构
>
> ``` c++
> class Child;
> 
> class Parent
> {
> public:
> 	Parent()
> 	{ cout << "Parent()" << endl; }
> 	~Parent()
> 	{ cout << "~Parent()" << endl; }
> 	//只需要Child类型的指针，不需要类的完整定义
> 	shared_ptr<Child> _spChild;
> };
> 
> class Child
> {
> public:
> 	Child()
> 	{ cout << "child()" << endl; }
> 	~Child()
> 	{ cout << "~child()" << endl; }
> 	shared_ptr<Parent> _spParent;
> };
> ```
>
> 



> 由于shared_ptr的实现使用了引用计数，那么如果进行如下的创建
>
> 
>
> ``` c++
> shared_ptr<Parent> parentPtr(new Parent());
> shared_ptr<Child> childPtr(new Child());
> //获取到的引用计数都是1
> cout << "parentPtr.use_count():" << parentPtr.use_count() << endl;
> cout << "childPtr.use_count():" << childPtr.use_count() << endl;
> ```
>
> <img src="D:/卓面/4th/05_CppBase/C++讲义/10.移动语义与资源管理.assets/undefined202403222027179.png" alt="image-20240322202756063" style="zoom: 50%;" />
>
> 
>
> 



> ``` c++
> parentPtr->_spChild = childPtr;
> childPtr->_spParent = parentPtr;
> //获取到的引用计数都是2
> cout << "parentPtr.use_count():" << parentPtr.use_count() << endl;
> cout << "childPtr.use_count():" << childPtr.use_count() << endl;
> ```

实际上形成了这样的结构

<img src="D:/卓面/4th/05_CppBase/C++讲义/10.移动语义与资源管理.assets/image-20240508115748981.png" alt="image-20240508115748981" style="zoom:50%;" />

——程序结束时，发现Parent和child的析构函数都没有被调用

因为childPtr和parentPtr会先后销毁，但是堆上的Parent对象和Child对象的引用计数都变成了1，而不会减到0，所以没有回收

<img src="D:/卓面/4th/05_CppBase/C++讲义/10.移动语义与资源管理.assets/image-20240508115701939.png" alt="image-20240508115701939" style="zoom:50%;" />





解决思路：

——希望某一个指针指向一片空间，能够指向，但是不会使引用计数加1，那么堆上的Parent对象和Child对象必然有一个的引用计数是1，栈对象再销毁的时候，就可以使引用计数减为0

shared_ptr无法实现这一效果，所以引入了weak_ptr.



> weak_ptr是一个弱引用的智能指针，不会增加引用计数。
>
> shared_ptr是一个强引用的智能指针。
>
> 强引用，指向一定会增加引用计数，只要有一个引用存在，对象就不能释放；
>
> 弱引用并不增加对象的引用计数，但是它知道所托管的对象是否还存活。



——循环引用的解法，将Parent类或Child类中的任意一个shared_ptr换成weak_ptr类型的智能指针

比如：将Parent类中的shared_ptr类型指针换成weak_ptr

<img src="D:/卓面/4th/05_CppBase/C++讲义/10.移动语义与资源管理.assets/image-20240508115831351.png" alt="image-20240508115831351" style="zoom:50%;" />

栈上的childPtr对象先销毁，会使堆上的Child对象的引用计数减1，因为这个Child对象的引用计数本来就是1，所以减为了0，回收这个Child对象，造成堆上的Parent对象的引用计数也减1

<img src="D:/卓面/4th/05_CppBase/C++讲义/10.移动语义与资源管理.assets/image-20240508120233748.png" alt="image-20240508120233748" style="zoom:50%;" />

再当parentPtr销毁时，会再让堆上的Parent对象的引用计数减1，所以也能够回收。

<img src="D:/卓面/4th/05_CppBase/C++讲义/10.移动语义与资源管理.assets/image-20240508120320252.png" alt="image-20240508120320252" style="zoom:50%;" />

##### weak_ptr的使用

weak_ptr是弱引用的智能指针，它是shared_ptr的一个补充，使用它进行复制或者赋值时，并不会导致引用计数加1，是为了解决shared_ptr的问题而诞生的。



> **初始化**
>
> ``` c++
> weak_ptr<int> wp;//无参的方式创建weak_ptr
> 
> //也可以利用shared_ptr创建weak_ptr 
> weak_ptr<int> wp2(sp);
> ```
>
> 



> **判断关联的空间是否还在**
>
> **1.可以直接使用use_count函数**
>
> 如果use_count的返回值大于0，表明关联的空间还在
>
> 
>
> **2.将weak_ptr提升为shared_ptr**
>
> ``` c++
> shared_ptr<int> sp(new int(10));
> weak_ptr<int> wp;//无参的方式创建weak_ptr
> wp = sp;//赋值
> ```
>
> 这种赋值操作可以让wp也能够托管这片空间，但是它作为一个weak_ptr仍不能够去管理，甚至连访问都不允许（weak_ptr不支持直接解引用）
>
> 想要真正地去进行管理需要使用lock函数将weak_ptr提升为shared_ptr
>
> ``` c++
> shared_ptr<int> sp2 = wp.lock();
> if(sp2){
> cout << "提升成功" << endl;
> cout << *sp2 << endl;
> }else{
> cout << "提升失败，托管的空间已经被销毁" << endl;
> }
> ```
>
> 如果托管的资源没有被销毁，就可以成功提升为shared_ptr，否则就会返回一个空的shared_ptr（空指针）
>
> 
>
> **——查看lock函数的说明**
>
> ```` c++
> std::shared_ptr<T> lock() const noexcept;
> //将weak_ptr提升成一个shared_ptr，然后再来判断shared_ptr,进而知道weak_ptr指向的空间还在不在
> ````



> 3.**可以使用expired函数**
>
> > ```C++
> > bool expired() const noexcept;
> > //weak_ptr去判断托管的资源有没有被回收
> > ```
> >
> > 该函数返回true等价于use_count() == 0.
> >
> > 
> >
> > ``` c++
> > bool flag = wp.expired();
> > if(flag){
> > cout << "托管的空间已经被销毁" << endl;
> > }else{
> > cout << "托管的空间还在" << endl;
> > }
> > ```
> >
> > 



### 删除器

很多时候我们都用new来申请空间，用delete来释放。库中实现的各种智能指针，默认也都是用delete来释放空间。

但如果我们是用fopen打开文件，这时智能指针的默认处理方式就不能解决了，<font color=red>**必须为智能指针定制删除器**</font>，也就是定制化释放资源的方式。

#### unique_ptr对应的删除器

<img src="D:/卓面/4th/05_CppBase/C++讲义/10.移动语义与资源管理.assets/image-20231107174351960.png" alt="image-20231107174351960" style="zoom: 80%;" />

定义unique_ptr时，如果没有指定删除器参数，就会使用默认的删除器。点开std::default_delete的说明

<img src="D:/卓面/4th/05_CppBase/C++讲义/10.移动语义与资源管理.assets/image-20231107174454514.png" alt="image-20231107174454514" style="zoom:80%;" />

默认删除器类型重载了函数调用运算符，底层是利用函数对象实现资源回收。

根据参考文档的说明，无论接管的是什么类型的资源，回收时都是会执行delete语句或delete [ ]



> 看下面这个例子
>
> ``` c++
> //文件指针原本的用法，ok
> void test0(){
> string msg = "hello,world\n";
> FILE * fp = fopen("res1.txt","a+");
> fwrite(msg.c_str(),1,msg.size(),fp);
> fclose(fp);
> }
> ```
>
> 
>
> 如果使用unique_ptr托管文件资源
>
> ``` c++
> //用unique_ptr托管文件资源，回收时有问题
> void test1(){
> string msg = "hello,world\n";
> unique_ptr<FILE> up(fopen("res2.txt","a+"));
> //get函数可以从智能指针中获取到裸指针
> fwrite(msg.c_str(),1,msg.size(),up.get());
> //fclose(up.get()); 
> }
> ```
>
> 一般地，智能指针的特点就是可以自动回收托管的资源，所以在接管资源后应该可以不用手动fclose
>
> 但是这样做会有<font color=red>**一个问题**</font> —— 内容msg并没有写到文件中去。
>
> 回顾一下fclose函数，如果没有fclose的调用，msg的内容存在缓冲区中，并不会刷新到文件流中。
>
> ![image-20240416173542819](D:/卓面/4th/05_CppBase/C++讲义/10.移动语义与资源管理.assets/image-20240416173542819.png)
>
> —— 如果显式进行fclose，则会出现double free的问题。
>
> 已回收的文件资源，由默认的删除器又会尝试进行一次回收。



> 问题的根本原因：接管文件资源时，智能指针在析构时也是使用delete语句来回收资源，导致错误
>
> ——需要自定义删除器
>
> 仿照参考文档上默认删除器的示例，创建一个代表删除器的struct，定义operator()函数
>
> ``` c++
> class FILEDeletor{
> public:
>  void operator()(FILE * fp){
>      if(fp){
>          fclose(fp);
>          cout << "fclose(fp)" << endl;
>      }
>  }
> };
> ```

> 创建unique_ptr接管文件资源时，删除器参数使用我们自定义的删除器
>
> ``` c++
> void test1(){
> string msg = "hello,world\n";
> unique_ptr<FILE，FILEDeletor> up(fopen("res2.txt","a+"));
> //get函数可以从智能指针中获取到裸指针
> fwrite(msg.c_str(),1,msg.size(),up.get());
> }
> ```

> <span style=color:red;background:yellow>**总结：**</span>
>
> 如果管理的是普通的资源，不需要写出删除器，就使用默认的删除器即可，只有针对FILE或者socket这一类创建的资源，才需要改写删除器，使用fclose之类的函数。

#### shared_ptr对应的删除器

> <span style=color:red;background:yellow>**unique_ptr 和 shared_ptr区别：**</span>
>
> 对于unique_ptr，删除器是模板参数
>
> <img src="D:/卓面/4th/05_CppBase/C++讲义/10.移动语义与资源管理.assets/image-20231107201437584.png" alt="image-20231107201437584" style="zoom:80%;" />

> 对于shared_ptr，删除器是构造函数参数
>
> <img src="D:/卓面/4th/05_CppBase/C++讲义/10.移动语义与资源管理.assets/image-20231107201537512.png" alt="image-20231107201537512" style="zoom:80%;" />



所以传入删除器参数的位置不同

``` c++
class FILEDeletor{
public:
 void operator()(FILE * fp){
     if(fp){
         fclose(fp);
         cout << "fclose(fp)" << endl;
     }
 }
};

void test1(){
    string msg = "hello,world\n";
    //在unique_ptr的模板参数中加入删除器类
    unique_ptr<FILE，FILECloser> up(fopen("res2.txt","a+"));
    fwrite(msg.c_str(),1,msg.size(),up.get());
}


void test2(){
    string msg = "hello,world\n";
    FILECloser fd;
    //在shared_ptr的构造函数参数中加入删除器对象
    shared_ptr<FILE> sp(fopen("res3.txt","a+"),fd);
    fwrite(msg.c_str(),1,msg.size(),sp.get());
}
```

###  智能指针的误用

智能指针被误用的情况，<span style=color:red;background:yellow>**原因都是将一个原生裸指针交给了不同的智能指针进行托管，而造成尝试对一个对象销毁两次**</span>。

对于shared_ptr与unique_ptr都会产生这个问题。

> —— unique_ptr要注意的误用
>
> ``` c++
> void test0(){//error
> //需要人为注意避免
> Point * pt = new Point(1,2);
> unique_ptr<Point> up(pt);
> unique_ptr<Point> up2(pt);
> }
> 
> void test1(){ //error
> unique_ptr<Point> up(new Point(1,2));
> unique_ptr<Point> up2(new Point(1,2));
> //让两个unique_ptr对象托管了同一片空间
> up.reset(up2.get());
> }
> ```
>
> 



> ——shared_ptr要注意的误用
>
> 使用不同的智能指针托管同一片堆空间,只能通过shared_ptr开放的接口——拷贝构造、赋值运算符函数
>
> 如果是用裸指针的形式将一片资源交给不同的智能指针对象管理，即使是shared_ptr也是不行的。
>
> <span style=color:red;background:yellow>**之前进行的shared_ptr的复制、赋值的参数都是shared_ptr的对象，不能直接多次把同一个裸指针传给它的构造。**</span>
>
> 
>
> ``` c++
> void test2(){ // error
> Point * pt = new Point(10,20);
> shared_ptr<Point> sp(pt);
> shared_ptr<Point> sp2(pt);
> }
> 
> void test3(){ //error
> //使用不同的智能指针托管同一片堆空间
> shared_ptr<Point> sp(new Point(1,2));
> shared_ptr<Point> sp2(new Point(1,2));
> sp.reset(sp2.get());
> }
> ```
>
> 



> —— 还有一种误用
>
> 给Point类加入了这样的成员函数
>
> ``` c++
> Point * addPoint(Point * pt){
> 	_ix += pt->_ix;
> 	_iy += pt->_iy;
> 	return this;
> }
> ```
>
> 
>
> 使用时，这样还是使得sp3和sp同时托管了同一个堆对象
>
> ```` c++
> shared_ptr<Point> sp(new Point(1,2));    
> shared_ptr<Point> sp2(new Point(3,4));
> 
> //创建sp3的参数实际上是sp所对应的裸指针
> //效果还是多个智能指针托管了同一块空间
> shared_ptr<Point> sp3(sp->addPoint(sp2.get()));
> cout << "sp3 = ";
> sp3->print();
> ````
>
> 
>
> ——需要给sp3的构造函数传入`shared_ptr<Point>` 对象，而不是裸指针



> <span style=color:red;background:yellow>**解决思路：**</span>
>
> **通过this指针获取本对象的shared_ptr**
>
> 可以修改Point中的addPoint函数
>
> ``` c++
> shared_ptr<Point> addPoint(Point * pt){
> 	_ix += pt->_ix;
> 	_iy += pt->_iy;
> 	return shared_ptr<Point>(this); 
> }
> ```
>
> 
>
> 但是这样写，在addPoint函数中创建的匿名智能指针对象接收的还是sp对应的裸指针，那么这个匿名对象和sp所托管的空间还是同一片空间。匿名对象在函数return时调用移动构造创建出副本，副本与sp还是共用一个裸指针。



> ——使用智能指针辅助类enable_shared_from_this的成员函数shared_from_this
>
> ![image-20231107205809125](D:/卓面/4th/05_CppBase/C++讲义/10.移动语义与资源管理.assets/image-20231107205809125.png)
>
> ![image-20231107205839620](D:/卓面/4th/05_CppBase/C++讲义/10.移动语义与资源管理.assets/image-20231107205839620.png)
>
> 在Point的addPoint函数中需要使用shared_from_this函数返回的shared_ptr作为返回值，要想在Point类中调用enable_shared_from_this的成员函数，最佳方案可以让Point类继承enable_shared_from_this类。
>
> 这样修改addPoint函数后，问题解决。
>
> 主要原理在于：
>
> - 当使用 `shared_ptr` 管理对象时，`enable_shared_from_this` 内部的 `weak_ptr` 会被初始化，指向该对象。
> - 调用 `shared_from_this()` 时，它会检查内部的 `weak_ptr` 是否有效，如果有效则返回一个新的 `shared_ptr`，与现有的 `shared_ptr` 共享所有权。
>
> ``` c++
> class Point 
> : public std::enable_shared_from_this<Point> 
> {
> public:
> 	//...
> 	shared_ptr<Point> addPoint(Point & pt) {
> 		_ix += pt._ix;
> 		_iy += pt._iy;
> 		return shared_from_this();
> 	}
> };
> 
> void test(){
>     shared_ptr<Point> sp(new Point(1,2));    
> 	shared_ptr<Point> sp2(new Point(3,4));
> 
> 	//创建sp3的参数实际上是sp所对应的裸指针
> 	//效果还是多个智能指针托管了同一块空间
> 	shared_ptr<Point> sp3(sp->addPoint(sp2.get()));
> 	cout << "sp3 = ";
> 	sp3->print();
> }
> ```
>
> **总结：智能指针的误用全都是使用了不同的智能指针托管了同一块堆空间（同一个裸指针）。**
