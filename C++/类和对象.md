# 类和对象

#### **面向对象的三大特性**

**封装：**通过访问修饰符将对象的属性和方法封装起来，外部实现时，只管使用接口调用，而不用在意实现。

**继承：**子类可以继承父类的属性和方法

**多态：**一个接口，多种实现，同一个操作作用在不同的对象可以有不同的行为。

#### 类与对象的关系

类是众多对象的共性的抽象，抽提总结，类如，车类

对象是由类实例化产生的，例如，自行车对象，摩托车对象，汽车对象。

类的定义分为两部分：数据成员和成员函数。

```C++
//c++中定义一个类可以先声明，再定义，也可直接定义
class Person{
    int age;//数据成员
    void setAge();//成员函数
    
};//结尾;不能丢
//先声明后定义
class Student;
class Student{
    
};
```

**访问修饰符/访问权限：**

**public：**公有的，无论在类的内部还是在类的外部均可访问。

**private:**私有的，仅内部可以访问，外部无法访问。

**protected:**保护的，在当前类和当前类的子类中可以自由访问，但是外部依旧无法访问。

**struct和class的对比**

c++中的struct基本等同于class,只是struct的默认修饰符为public，而class的默认修饰符为private

#### **成员函数**

类的内部定义

```C++
class Computer{
  public :
    void setBrand(const char *brand){
        strcpy(_brand,brand);
    }
  private:
    char _brand[20];
};
```

类的内部声明，外部定义

```C++
class Computer{
  public :
    //内部定义
    void setBrand(const char *brand);
  private:
    char _brand[20];
};
//外部实现
//成员函数需要使用类名::标识当前函数属于类的成员函数
//虽然函数的定义在外部，但是依然可以访问类里的私有成员。
 void Computer::setBrand(const char *brand){
       strcpy(_brand,brand);
 }
```

类的声明和定义放置在不同文件中，比如头文件和实现文件。

```C++
//Person头文件
class Person{
  public:
    void setName(const char *name);
    void setAge(int age);
    private:
    char _name[20];
    int _age;
};
//Person实现文件
#include "Person"
void setName(const char *name){
        strcpy(_name,name);
    }
void setAge(int age){
    _age=age;
}
```



#### <font color='red'>构造函数</font>

**作用：**为了完成数据成员的初始化工作。

**调用时机：**会在当前对象被创建的时候调用，而且只会被调用一次。

**形式：**没有返回值，函数名和类名相同，再加上函数参数列表。

**特征：**当类中没有显式定义构造函数时，会默认创建一个无参构造函数，但并不会初始化数据成员。当类中显式提供了构造函数，编译器就不会提供默认构造函数。

```C++
class point{
public:
    Point(int x,int y){
        //c++认为下面两行严格意义上来说，依然不能够算做初始化，而是赋值操作
        int _x=x;
        int _y=y;
    };
    Point();//构造函数可以形成函数重载。
private:
    int _x;
    int _y;
};
void test(){
    //创建类对象时，会调用构造函数，但是下面调用了无参构造函数，因为此时我们自己提供了一个有参构造函数，默认的无参构造函数不会调用，会错误
    Point p;//error
    Point p(1,2)//rigth
}
```

##### **初始化列表**

在c++中初始化数据成员，推荐使用初始化列表。

形式：初始化列表位于构造函数形参列表之后，函数体之前，用冒号开始，如果有多个数据成员，再用逗号分隔，初始值放在一对小括号中。

```C++
class Point{
public:
    Point(int x,int y)
    :_x(x)
    ,_y(y)
    {
        
    }
private:
    int _x;
    int _y;
};
```

**<font color='red'>数据成员的初始化并不取决于其在初始化列表中的顺序，而是取决于在声明时的顺序。</font>**

```C++
class Point{
public:
    Point(int value)
    :_y(value)
    ,_x(_y)
    {
        
    }
private:
    int _x;
    int _y;
};
int main()
{
    Point pt(3);
    //32456  3
    //89027  3
    //90289  3
    //x      y
    //x并不会等于y,因为每次都会先初始化x，再初始化y
    cout << "Hello world" << endl;
    return 0;
}
```

为了减少错误的产生，强烈建议初始化列表中的顺序和声明的顺序一致。

#### **对象空间大小**

成员函数所存储的内存区域（程序代码区）和数据成员所存储的地方不一样。

类的成员函数并不会影响类对象的空间大小

##### **内存对齐规则：**

1.第一个数据成员放在offset偏移量为0的地方，后续的每一个数据成员需要放置在自身数据成员长度的位置，比如int所占4字节，那么可以存放偏移量为0，4的位置，比如double所占8字节，那么可以存放在偏移量为0，8等位置

```c++
class A{
    int a;
    char b;
    int c;
    int d;
}
void test(){
    cout<<sizeof(A)<<endl;//16
}
```

|  0   |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
|  a   |  a   |  a   |  a   |  b   |  x   |  x   |  x   |
|  c   |  c   |  c   |  c   |  d   |  d   |  d   |  d   |

2.在数据成员完成各自对齐之后，结构体/类本身也要进行对齐，按照最大数据成员的大小进行对齐。

```C++
class B{
    int a;
    char b;
    float c;
    class B_A{
        int d;
        double e;
    }SBA;
    int f;
}
void test(){
    cout<<sizeof(B)<<endl;//40
}
```

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | a    | a    | a    | b    | x    | x    | x    |
| c    | c    | c    | c    | x    | x    | x    | x    |
| d    | d    | d    | d    | x    | x    | x    | x    |
| e    | e    | e    | e    | e    | e    | e    | e    |
| f    | f    | f    | f    | x    | x    | x    | x    |

3.如果一个结构体里有某些结构体成员，则内部结构体成员要从成员最大元素大小的整数倍开始存储。

```C++
class C{
    char a[2];
    short b;
    class C_A{
        int c;
        double d;
        float e;
    }SCA:
}
void test{
    cout<<sizeof(C)<<endl;//32
}
```

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | a    | b    | b    | x    | x    | x    | x    |
| c    | c    | c    | c    | x    | x    | x    | x    |
| d    | d    | d    | d    | d    | d    | d    | d    |
| e    | e    | e    | e    | x    | x    | x    | x    |



#### <font color='red'>**指针数据成员**</font>

```C++
class Computer{
public:
    Computer(const char *brand,float price)
        :_brand(brand)//error
         ,_price(price)
        {
            
        }
    private:
    char *_brand;
    float _price;
};
```

指针数据成员的使用

1.像内置数据成员一样，将一个指针数据成员的值赋值给另外一个指针数据成员（抛开const限定的一些因素），**浅拷贝**，两个指针数据成员指向同一个内存空间。

如果指向的是常量区，无法修改指针所指向的内存区域的值。

如果指向的是堆区，可能销毁时会出现问题，例如一个指针进行了堆空间的回收，另外一个指针进行了同样的操作；一个指针回收了堆空间，另外一个指针还在继续使用

2.先申请内存空间，再进行对应的拷贝过程。**深拷贝**

两个指针分别指向的是不同的内存区域，但是这两个内存区域里面存储的值相同

#### <font color='red'>**析构函数**</font>

析构函数会在当前对象被销毁时调用，没有开发者介入的情况下，也只会调用一次。

**作用：**清理对象的数据成员申请的堆空间，并不负责去清理数据成员。

**形式：**和构造函数非常相似，只不过比构造函数的形式要求更为严格一些。析构函数的函数名称和类名相同，但是前面有一个~,无返回值，形参是无参的，没有函数重载的形式。

```C++
~Computer(){
    
}
```

析构函数可以利用对象.的方式来进行调用。不建议此操作。

**<font color='red'>调用析构函数不会导致对象的销毁，对象销毁的时候会调用析构函数，并不是调用析构函数会导致对象销毁。</font>**

##### **析构函数的调用时机**

**1.全局对象**

<font color='red'>整个程序结束时</font>

**2.局部对象**

<font color='red'>在程序离开局部对象作用域时</font>

**3.静态对象**

<font color='red'>在整个程序结束时</font>

**4.堆对象**

<font color='red'>在使用delete删除该对象时</font>

#### <font color='red'>**拷贝构造函数**</font>

如果没有创建拷贝构造函数时，编译器会默认提供一个拷贝构造函数的实现。

拷贝构造函数也是构造函数

编译器默认提供的拷贝构造函数是采用浅拷贝的方法

**形式：**类名(const 类名 &) 

```c++
//其中rhs变量的名称相对比较固定，表示右操作数
Point(const Point &rhs){
    
}
```

采用拷贝构造函数可以实现通过一个对象来初始化另一个对象。

```C++
#include <iostream>
#include <string.h>
using std::cout;
using std::endl;
using std::cin;
//拷贝构造函数
class Student{
public:
    //构造函数
    Student(char *name,int age)
    :_name(new char[strlen(name)+1]())
    ,_age(age)
    {
        strcpy(_name,name);
    }
    //析构函数
    ~Student(){
        if(_name){
            delete []_name;
            _name=nullptr;
        }
    }
private:
    char *_name;
    int _age;
};
void test(){
    Student s("zs",22);
    Student s2(s);
    s2.printf_Info();
}

int main()
{
 test();
 return 0;
}

```

但是上述代码的结果有问题。

![image-20250707213253390](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250707213253390.png)

为什么会产生doule free问题？

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250707213340332.png" alt="image-20250707213340332" style="zoom:50%;" />

因为上述代码没有定义拷贝构造函数，编译器自动提供了一个采用浅拷贝的拷贝构造函数，使得s1和s2的指针指向了同一个内存区域，当test函数执行完后，栈上的s1和s2都会去销毁zs这片内存区域，s2销毁完后，当s1调用析构函数再一次去销毁时，就会造成doule free。

那么如何解决这个问题呢？

非常简单，将浅拷贝改为深拷贝就可以了。

```c++
   Student(const Student &rhs)
    :_name(new char[strlen(name)+1]())
    ,_age(rhs._age)
    {
        strcpy(_name,name);
    }

```

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250707215549719.png" alt="image-20250707215549719" style="zoom:50%;" />

##### <font color='red'>**拷贝构造函数的调用时机**</font>

1.当使用一个已经存在的对象初始化另外一个同类型的对象时。

```c++
class Point{
public:
    //构造函数
    Point(int x,int y)
    :_x(x)
    ,_y(y)
    {
        
    }
    //拷贝构造函数
    Point(const Point &rhs)
    :_x(rhs.x)
    ,_y(rhs.y)
    {
        
    }
private:
    int _x;
    int _y;
};
void test(){
    Point p1(1,2);
    Point p2(p1);
    Point p3=p1;
}
```

2.当函数参数（实参和形参的类型都是对象），形参与实参结合时（实参初始化形参）。

```C++
void func(Point p){
    p.print();
}
void test(){
    Point pt(1,2);
    func(p);
}
```

3.当函数的返回值是对象，执行return语句时。

```C++
Point p(1,2);
Point func(){
    return p;
}
void test(){
    func();
}
```

返回全局对象，默认会调用拷贝构造函数，但是如果返回是一个局部对象，需要添加去优化指令，才会调用拷贝构造函数。

```C++
g++ xxxx.cc -fno-elide-constructors --std=c++11
```

不要返回局部对象的引用，局部对象出了作用域就会被销毁。

```C++
Point & func(){
    Point localpoint(1,3);
    return localpoint;
}
void test{
    Point pt=func();//error
}
```

**拷贝构造函数的形式探究？**

**思考：**1.是否可以去掉引用符号

```c++
class Point{
public:
    //构造函数
    Point(int x,int y)
    :_x(x)
    ,_y(y)
    {
        
    }
    //拷贝构造函数
    Point(const Point rhs)//error
    :_x(rhs.x)
    ,_y(rhs.y)
    {
        
    }
private:
    int _x;
    int _y;
};
```

不可以去掉引用符号，因为去掉引用符号，编译器会直接报错。

因为去掉之后拷贝构造函数的形参是一个对象，当我们去调用拷贝构造函数的时候，实参和形参相结合会进一步调用拷贝构造函数，那么就需要形参和实参相结合，刚好符合拷贝构造函数调用的时机2，那么又需要调用拷贝构造函数，陷入递归。

**思考：**2.拷贝构造函数是否可以去掉const?

```C++
class Point{
public:
    //构造函数
    Point(int x,int y)
    :_x(x)
    ,_y(y)
    {
       cout<<"Point(int ,int)"<<endl; 
    }
    //拷贝构造函数
    Point(Point &rhs)
    :_x(rhs._x)
    ,_y(rhs._y)
    {
        cout<<"Point(const Point &)"<<endl;
    }
private:
    int _x;
    int _y;
};
void test(){
    Point p(1,2);
    Point p2(p1);
}
```

不建议去掉const ,因为去掉之后可以操作右操作数，即改变原对象。

```C++
 Point(Point &rhs)
    :_x(rhs.x)
    ,_y(rhs.y)
    {
        rhs._x=0;
        rhs._y=0;
        cout<<"Point(const Point &)"<<endl;
    }
```

如果去掉将无法处理右值，临时对象的拷贝。加上const就可以了。主要原因在于const 引用可以绑定左值，也可以绑定右值，如果绑定的是一个右值，那么会将右值的生命周期提升到和引用变量相同。

```C++
void test(){
    Point p=Point(1,2)//error
}
```

左值可以取地址

右值不可以取地址，临时变量，临时对象

一般情况下有名称的是左值，没有名称的是右值（有例外）

“Hello World”字符串常量是左值，可以取地址。

#### **<font color='red'>赋值运算符</font>**

和拷贝构造函数有点相似，需注意。

```C++
Point p1(1,2),p2(3,4);
p1=p2;//赋值操作
Point p3=p2;//拷贝构造
```

**区别：**主要在于左操作数的前面是否有数据类型，有数据类型

**形式：**

```C++
类名 & operator=(const 类名 &rhs)
```

那么赋值运算符的返回值是什么？

**this指针**

this指针的本质是一个常量指针  `Type* const pointer`; 它储存了调用它的对象的地址，不可被修改。这样成员函数才知道自己修改的成员变量是哪个对象的。

**this**是一个隐藏的指针，可以在类的成员函数中使用，它可以用来指向调用对象。当一个对象的成员函数被调用时，编译器会隐式地传递该对象的地址作为 this 指针。

**this指针指向本对象**

**this指针的生命周期起始于成员函数的执行开始，结束于成员函数的结束**。

<font color='red'>**赋值运算函数的正确编写**</font>

**四步走：**

1. 考虑自赋值问题
2. 回收左操作数的数据成员原本申请的堆空间
3. 深拷贝（以及其他的数据成员的赋值）
4. 返回*this（本对象）

```C++
Computer & operator=(const Computer &rhs){
    if(this!=&rhs){
        delete [] _brand;
        _brand=new char[strlen(rhs._brnad)+1]();
        strcpy(_brand,brand);
        _price=price;
    }
    return *this;
}
```

**形式探究：**

1.赋值运算符的返回值必须是一个 引用吗？

可以不返回，但是**建议返回一个引用**，否则会满足拷贝构造函数的时机，再一次进行拷贝构造调用。

2.返回值可以是void吗？

可以，但是如果返回值是void那么将无法去处理连续赋值的场景。

```C++
Point p1(1,2),p2(3,4),p3(5,6);
p1=p2=p3;//error
```

3.赋值运算符的函数参数一定要是一个引用吗？

可以不是，但是**建议是引用**，否则会多一次拷贝构造函数的调用。

4.赋值运算符的函数参数一定要是一个const引用吗？

是，否则无法去处理右值的赋值操作。

```C++
void test(){
  Point p1(1,2),p2(3,4),p3(5,6);
  p1=Point (9,10);//error
}
```

**三合成原则**

析构函数，拷贝构造函数，赋值运算符函数如果重写了其中一个，另外两个也需要重写。

如果只是为了打印日志，这种情况排除在外。

#### 特殊的数据成员

##### **1.常量数据成员**

当数据成员用const关键字进行修饰后，就成为了常量数据成员。

普通的const常量必须在声明时就初始化，初始化之后就不再允许修改值；

const成员初始化后也不再允许修改值。

**必须在构造函数的初始化列表中进行初始化。**

在普通构造函数体内，只能对成员变量进行赋值操作，而赋值操作针对的是可修改的变量，不能用于初始化常量。只有在构造函数初始化列表中，才能真正完成常量数据成员的初始化工作。

```C++
class Point{
public:
    Point(int x,int y)
    :_x(x)
    ,_y(y)
    {
        _x=x;//error
        _y=y;//error初始化后不再允许修改值
    }
private:
    const int _x;
    cosnt int _y;
}
```

##### **2.引用数据成员**

引用一旦和某个变量绑定了之后，就不可以再绑定到其它的变量。注意不要绑定一个局部变量的引用。

```C++
class Point{
public:
    
    Point(int x,int y,int z)
    :_x(x)
    ,_y(y)
    ,_z(z)//error _z的值不固定，因为当使用构造函数初始化完后，Z就会被销毁，_Z绑定的是一个形参，未知的区域，是未定义行为。
    {
    }
    //可以采用以下的绑定方法
    Point(int x,int y)
    :_x(x)
    ,_y(y)
    ,_z(x)
    {
        
    }
    void print(){
        cout<<_x<<" "<<_y<<" "<<_z<<" "<<endl;
    }
private:
    int _x;
    int _y;
    int & _z;
}
```

在构造函数体内只能进行赋值操作，而赋值操作并不能满足引用必须在定义时初始化的要求，只有在构造函数初始化列表中，才能在定义引用数据成员的同时完成初始化。

必须得在构造函数的初始化列表中进行初始化，但是引用绑定的变量的生命周期应当不短于引用成员变量的生命周期。

##### **3.对象数据成员**

有时候一个类对象会作为另外一个类对象的数据成员来使用，这就是对象数据成员。

对象数据成员也必须在构造函数的参数列表中进行初始化。

如果不在构造函数初始化列表中提供合适的初始化方式，对象数据成员就无法被正确初始化。而在构造函数初始化列表中，可以直接调用对象数据成员对应类的合适构造函数来完成初始化。

对象数据成员一定会被初始化，优先根据我们在初始化列表中设定的值进行初始化，如果没有上一步，会调用默认构造函数进行初始化，如果这一步也没有，则直接出错。

**初始化列表中写的是需要被初始化的对象成员的名称，而不是对象成员的类名。**

```C++
class point{
public:
    Point(int x,int y)
    :_x(x)
    ,_y(y)
    {
        
    }
private:
    int _x;
    int _y;
};
class Line{
public:
    Line(int x,int y,int z,int u)
    //如果没有在Line的构造函数的初始化列表中显示调用Point的构造函数,那么会自动调用Point的无参构造
    :_pt1(x,y)
    ,_pt2(z,u)
    {
        
    }
private:
    Point _pt1;
    Point _pt2;
};
```

对象数据成员和内置数据类型的数据成员有一些不太一样的地方，那就是对象数据成员必须进行进行初始化操作。

如果不想用Point的无参构造，那么必须在Line类的初始化列表中对Point类的对象成员进行初始化.

关于数据成员的初始化，还可以使用另外一种形式。

```C++
#include <iostream>
using std::cout;
using std::endl;

class Point{
private:
    int _x;
    int _y;

public:
    Point(int x, int y)
    :_x(x)
    ,_y(y)
    {
        cout << "Point构造函数" << endl;
    }

    ~Point(){
        cout << "Point析构函数" << endl;
    }
    Point(const Point & rhs)
    :_x(rhs._x)
    ,_y(rhs._y)
    {
        cout << "Point拷贝构造函数" << endl;
    }
};


class Line{
private:
    //这里面会有拷贝构造函数调用
    //如果想要避免，这里面直接写引用
    Point & _pt1;
    Point & _pt2;

public:
    //这里面也需要引用，满足拷贝构造函数的调用时机2
    Line(Point & pt, Point & pt2)
    :_pt1(pt)
    ,_pt2(pt2)
    {
        cout << "Line构造函数" << endl;
    }

    ~Line(){
        cout << "Line析构函数" << endl;
    }
};

void test(){
    Point pt1(1, 2), pt2(3,5);
    Line line(pt1, pt2);
}

int main()
{
    test();
    cout << "Hello world" << endl;
    return 0;
}
```

**<font color='red'>思考：</font>**当某个类持有对象数据成员时，构造函数与析构函数的调用顺序是如何执行的。

```C++
public:
    //这里面也需要引用，满足拷贝构造函数的调用时机2
    Line(Point & pt, Point & pt2)
    :_pt1(pt)
    ,_pt2(pt2)
    {
        cout << "Line构造函数" << endl;
    }

    ~Line(){
        cout << "Line析构函数" << endl;
    }
};
```

![image-20250708195901350](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250708195901350.png)

这时候并不会如上图所示进行调用，因为Point构造函数的调用是在Line构造函数调用的过程中调用的，只是由于Line的输出语句位于Point构造函数调用之后。

但是析构函数的调用如图所示，会先调用Line的析构函数，再去调用Point的析构函数。**为什么？**

因为Line持有Point,可能存在在Line中访问Point的信息的场景。如果先析构Point再析构Line可能会出现读到脏乱数据的情况。

如果Line中申请了堆空间，同时两个Point数据成员也申请了堆空间，那么这三者堆空间资源的回收顺序是如何呢？

还是先析构Line再析构Point

##### **4.静态数据成员**

**不可以**在构造函数初始化列表中进行初始化。

因为静态数据成员属于类，而非对象，构造函数的初始化列表用于初始化对象的成员。

静态数据成员是类的所有对象共享的变量，无论创建了多少个对象，但是静态数据成员只有一份实例。

静态数据成员被整个类的所有对象共享。

在创建对象之前被创建,被初始化。

存储在全局/静态区，并不占据对象的存储空间。

静态数据成员初始化，需要在类的外部进行，不需要再去写static关键字，同时需要标注类名::xx。

如何访问静态数据成员？

1.直接通过类名去访问，较常用。

2.通过对象去访问。

```C++
class Computer{
public:
private:
   char *_brand;
   int _price;
   static double _totalprice;
};
double Computer::_totalprice=0;
void test(){
    cout<<Computer::_totalprice<<endl;
    Computer c;
    cout<<c._totalprice<,endl;
}
```

#### **特殊的成员函数**

**静态成员函数**

在某一个成员函数的前面加上static关键字，这个函数就是静态成员函数。静态成员函数具有以下特点：

（1）<span style=color:red;background:yellow>**静态成员函数不依赖于某一个对象；**</span>

（2）静态成员函数可以通过对象调用，但更常见的方式是<font color=red>**通过类名加上作用域限定符调用**</font>；

（3）**静态成员函数没有this指针；**

（4）<font color=red>**静态成员函数中无法直接用成员的名字访问非静态的成员（数据成员、成员函数）**</font>，只能访问静态数据成员或调用静态成员函数（因为没有this指针）。

（5）如果希望在静态成员函数中去访问非静态的成员，可以通过函数传参或者在静态成员函数中创建对象的形式间接操作

构造函数、拷贝构造、赋值运算符函数、析构函数比较特殊，可以在静态成员函数中调用。

**注意：非静态成员函数可以访问到静态成员函数或者静态数据成员。**

```C++
class Computer{
public:
    //静态成员函数是不可以直接访问非静态的数据成员或者成员函数
    //如果实在希望访问，那么可以再静态成员函数的参数中传递一个对象
    //或者直接在静态成员函数处去创建一个对象，进而去访问
    //static void static_func(){
    static void static_func(Computer c){
        //因为它没有this指针，所以无法访问到非静态的数据成员
        //cout << _brand << _price << endl;error 
        //print();error 
        cout << _totalPrice << endl;
        cout << c._brand << endl;
        c.print();
    }
    static void static_func2(){
        Computer c;
        c.print();
    }

    //在非静态的成员函数中可以访问静态数据成员以及静态成员函数
    void print(){
        cout << _totalPrice << endl;
        static_func2();
        cout << "Computer::print" << endl;
    }

private:
    char * _brand;
    float _price;
    static float _totalPrice;
};
float Computer::_totalPrice = 0;
```

静态成员函数以及静态数据成员都不依赖于某个具体的对象，并且生命周期远远早于数据成员和成员函数的生命周期。

**Const成员函数**

const 在类成员函数中还有种特殊的用法。在成员函数的参数列表之后，函数执行体之前加上const关键字，这个函数就是const成员函数。

**形式：**void func() const {}

cosnt成员函数中的数据成员只具有只读属性

```c++
//二者可以共存，说明形成了函数重载
//this指针不同
void print() const{
    //cosnt Point * cosnt this;
    //既不可以变更指向，也不可以通过指针去修改所指向的内容
    Point pt;
    this=&pt;//error
    this->x=0;//error
    this->y=0;//error

}
void print(){
    //Point *cosnt this;
    //可以通过this指针去修改所指向的值
    this->x=0;
    this->y=0;

}
```

#### **对象的组织**

**const对象**

类对象也可以声明为 const 对象，一般来说，能作用于 const 对象的成员函数除了构造函数和析构函数，就只有 const 成员函数了。因为 const 对象只能被创建、撤销和只读访问，写操作是不允许的。

```C++
const Point pt(1,2);
pt.print();//error const对象只能调用const成员函数，不能调用其它非const成员函数
```

```C++
void test(){
    cosnt Point pt1(1,2);
    Point pt2(3,4);
    pt1.print();//const对象调用cosnt成员函数
    pt2.print();//非cosnt对象调用非const成员函数
}
```

当类中有const成员函数和非const成员函数重载时，const对象会调用const成员函数，非const对象会调用非const成员函数。

如果类中只有一个const成员函数，无论const对象还是非const对象都可以调用这个版本。

当类中只有一个非const成员函数时，const对象就不能调用非const版本。

const成员函数中this指针的限定，是不可以通过指针去修改所指向的值，指向的是一个对象，所以这个对象里面的所有的部分都不可以修改；对于指针数据成员来说，里面存储的地址值是不可以变更的。

**思考：**const成员函数中不允许修改数据成员，const数据成员初始化后不允许修改，其效果是否相同？

举例，如果有一个普通的指针成员，在const成员函数中，它被如何限制？

> 对于普通类型的数据成员，const数据成员初始化后不允许修改，在const成员函数中无论是const数据成员还是非const数据成员，都不能修改值；
>
> 对于指针类型的数据成员：
>
> const int * p，初始化之后在任何地方都不能修改其指向的值（无论在const成员函数中还是在非const成员函数中），在非const成员函数中可以修改指向，在const成员函数中不能修改指向；
>
> int * p,在非const成员函数中可以修改指向，也可以修改值，在const成员函数中不能修改指向，可以修改指向的值。

**指向对象的指针**

形式：

类名 * 指针名 [=初始化表达式];

```C++
class Point{
public:
    Point(int x,int y)
    :_x(x)
    ,_y(y)
    {
        
    }
     void print(){
         cout<<_x<<" "<<_y<<endl;
     }   
private:
    int _x;
    int -Y;
};
void test(){
    //这是一种初始化方式，后续使用再进行赋值即可。
    Point *p=nullptr;
    //方式2
    Point pt(1,2);
    Point *p2=&pt;
    //方式3 指针去指向堆区
    Point *p3=new Point(1,3);
    //指针的使用：箭头，解引用
    p2->print();
    (*p3).print();
    delete p3;
    p3=nullptr;
}
```

**对象数组**

声明：

Point p[3];

```C++
void test(){
    int arr[5];
    //如果这种方式声明，需要进行元素实例化。需要借助无参构造函数来进行实例化。
    Point p[5];//error
    //解决方法：1.提供无参构造函数，2.下面的方式
    Point p[5]={Point(1,2),Point(1,2),Point(1,2),Point(1,2),Point(1,2)};
}
```

**堆对象**

```C++
void test(){
    int *p=new int(10);
    int *p2=new int[10]();
    
    Point *p1=new Point(1,2);
    Point *p2=new Point[10]();//error
    //解决方法：1.提供无参构造函数 2.使用{}来进行初始化
    p1->print();
    (*p1).print();
    (p2+1)->print();
    (*(p2+1)).print();
}
```

#### new/delete表达式的工作过程

**思考：**当我们使用new/delete表达式去创建一个堆对象或者回收堆空间时，究竟做了什么事情？

**new表达式工作步骤：**

1.先调用operator new库函数申请堆空间,调用时需要传递一个size大小，该大小就是类对象的大小，可以通过sizeof来得到。

```C++
//默认的operator new
void *operator new(size_t size){
    void *result=malloc(size);
    return result;
}
```

2.在申请的堆空间中调用构造函数完成数据成员的初始化操作。

3.将申请好的堆空间首地址赋值给指针变量。

**delete表达式工作步骤**

1.先调用析构函数，完成当前数据成员申请的堆空间的回收清理工作。

2.调用operator delete 库函数（对于free库函数的进一步封装），回收对象所在空间。

```C++
//默认的operator delete
void operator delete(void *p){
    free(p);
}
```



#### 创建对象的探究

**创建堆对象需要什么条件？**

需要公有的构造函数，operator new,operator delete 库函数，但是对于析构函数没有要求。

**创建栈对象需要什么条件？**

需要公有的构造函数和析构函数，对于operator new ,operator delete库函数没有任何要求。

**希望只可以创建堆对象，不可以创建栈对象？**

析构函数设置为私有。

虽然此时堆对象可以创建，但是如何去回收呢？

可以自己封装一个方法，在内部去调用析构函数。

**希望只可以创建栈对象，不可以创建堆对象？**

需要将operator new和operator delete 库函数设置为私有。



#### **<font color='red'>单例设计模式</font>**

什么叫设计模式：

其实在编程中就是指的是编程经验的总结，

单例模式指的是某个类class只有一个实例化对象，无论如何创建，那么最终整个系统中只有唯一一个实例对象。

**思考:如何确保某个类只能创建一个对象？**

1.一定得保证构造函数不能被外部程序随意调用。

2.内部创建一个对象，暴露给外部程序。

3.设计一个函数，该函数需要是静态成员函数，需要将对象放置在静态区，返回引用。

4.删除拷贝构造函数。

**单例创建在静态区**

```C++
#include <iostream>
using std::cout;
using std::endl;
using std::cin;
class Singleton{
public:
    static Singleton & getInstance(){
        static Singleton s;
        cout<<&s<<endl;
        return s;
    }
    void print(){
        cout<<"hello world"<<endl;
    }
private:
    //将构造函数私有
    Singleton(){}
    //删除拷贝构造函数
    Singleton(const Singleton & rhs)=delete;
    //删除赋值运算函数
    Singleton & operator=(const Singleton &rhs)=delete;
};
void test(){
    Singleton & s1= Singleton::getInstance();
    s1.print();
    Singleton::getInstance();
}

int main()
{
    test();
    return 0;
}

```

![image-20250709153440909](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250709153440909.png)

**单例创建在堆上**



```C++
#include <iostream>
using std::cout;
using std::endl;
using std::cin;
class Singleton{
public:
    static Singleton *getinstance(){
        if(instance==nullptr){
            instance=new Singleton();
        }
        cout<<instance<<endl;
        return instance;
    }
    void print(){
        cout<<"hello world"<<endl;
    }

private:
    static Singleton *instance;
    //构造函数私有
    Singleton(){}
    //删除拷贝构造函数
    Singleton (const Singleton &rhs)=delete;
    //删除赋值运算函数
    Singleton & operator=(const Singleton &rhs)=delete;
};
Singleton * Singleton::instance=nullptr;
void test(){
       Singleton *s=Singleton::getinstance();
       Singleton *s1=Singleton::getinstance();
       s->print();
    delete s;
    delete s1;//error double free
    //可以将析构函数设置为私有
}

int main()
{
 test();
 return 0;
}

```

**为什么创建单例模式时，要删除拷贝构造函数和赋值运算函数？**

![image-20250709160813904](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250709160813904.png)

```C++
void test(){
    Singleton &s1=Singleton::getinstance();
    Singleton s2(s1);
}
```

如果没有删除拷贝构造函数，此时的s2是s1的一个副本，破坏了单例的唯一性。

如果单例类不管理资源且无内部状态，赋值操作后可能不会导致错误，但是仍违反了单例模式的设计原则。

如果如果单例管理资源（如文件句柄、网络连接），赋值操作可能导致资源被多次释放：

```C++
class Database {
private:
    FILE* file;  // 管理文件资源
    Database() { file = fopen("data.db", "r"); }
    // 未删除赋值运算符
public:
    ~Database() { fclose(file); }  // 析构时关闭文件
    static Database* getInstance() { /* ... */ }
};

// 错误使用
Database* db1 = Database::getInstance();
Database* db2 = Database::getInstance();
*db1 = *db2;  // 默认赋值使db1和db2的file指针相同
// 程序结束时，db1和db2的析构函数都会调用fclose(file)，导致重复关闭
```

**单例的使用场景**

1.有频繁实例化然后销毁的情况，也就是频繁new

#### <font color='red'>**S<font color='red'>tring</font>**</font>

##### **c++风格字符串**

使用string ,需要使用构造函数来创建一个string对象。

string的本质就是对于c风格字符串const char *的进一步封装。

```C++
string s//无参构造
string s2(2,'h');//hh 数量加字符
string s3("hello");//hello 使用c风格字符串创建string对象.
string s4("hello",3)//hel,使用hello的前3个字符来构造
string s5=s4;//hel
string s6(s5);//hel
char str[6]="hello";
string s7(str,str+6);//hello
```

##### 字符串的拼接

```C++
void test(){
    string s1("hello");
    string s2("world");
    s1.append(s2);//helloworld
    s1+=s2;//helloworldworld
    
}
```

##### string类对象和c风格字符串的转化

```C++
void test(){
    //c风格转化为string对象
    string s("hello");
    const char *pstr="world";
    string s2(pstr);
    //string 对象转化成c风格字符串
    const char *pstr2=s.c_str();
    const char *pstr3=s.data();
}
```

##### **字符串的常用功能**

```C++
#include <iostream>
using std::cout;
using std::endl;
using std::cin;
using std::string;
void test(){
    string s1;
    string s2="hello";
    cout<<s2.empty()<<endl;//判断字符串是否为空
    //获取字符串的长度
    cout<<s2.size()<<endl;
    cout<<s2.length()<<endl;
    //在字符串末尾追加字符
    s2.push_back('h');
    s2.append(3,'w');//添加3个w
    s2.append("world");//添加字符串
    s2.append("wqer",0,3);//从原字符串末尾添加str从0开始的三个字符
    cout<<s2<<endl;
    string s3="hello";
    s3+=" world";
    cout<<s3<<endl;
    //find 
    //
    cout<<s3.find("he",0)<<endl;//从字符串的pos为开始查找字符串he
    cout<<s3.find('l',0)<<endl;//从pos位开始查找字符
    cout<<s3.find("helo",0,2)<<endl;//从0开始去查找c字符串str的前2个字符
}

int main()
{
    test();
    return 0;
}

```

![image-20250710141807531](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250710141807531.png)

##### **字符串的比较**

```C++
#include <iostream>
using std::cout;
using std::endl;
using std::cin;
using std::string;
void test(){
    string s1("hello world");
    string s2("hello World");
    cout<<(s1==s2)<<endl;
    cout<<(s1!=s2)<<endl;
    cout<<(s1>=s2)<<endl;
    cout<<(s1<=s2)<<endl;
    cout<<(s1>s2)<<endl;
    cout<<(s1<s2)<<endl;
}
int main()
{
 test();
 return 0;
}

```

![image-20250710200252323](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250710200252323.png)

##### <font color='red'>**字符串的遍历**</font>

```C++
void test(){
    string s("hello");
    //方式1.下标遍历
    for(int i=0;i<s.length();i++)     {
        cout<<s[i]<<endl;
    }
    //方式2，增强for遍历
    //为了避免拷贝操作，可以添加引用
    for(auto &ch:s){
        cout<<ch<<endl;
    }
    //方式3，迭代器访问
    auto it=s.begin();
    while(it!=s.end()){
        cout<<*it<<endl;
        it++;
    }
}
```

#### Vector动态数组

std::vector是一个动态数组容器，可以存放任意类型的数据。

**explict 添加了该关键字，表示禁止隐式类型转换。**

##### vector的构造

```C++
void test(){
    //无参构造函数，<>里面存放的可以是内置数据类型，也可以是自定义数据类型。
    Vector<int> number;
    Vector<int> number2(10);//初始化10个int ,默认值为当前数据类型的0值。
    Vector<int> number3(10,20);//10表示10个元素，20表示每个元素的值。
    vector<int> number{1,2,3,4,5};
    //通过参数列表初始化vector,直接指明存放的所有元素值。
    vector<int> num(number.begin(),number.end()-2);//迭代器初始化vector,传入两个迭代器作为参数。
```

reserver 一次性申请好所需的空间。

```c++
//pop_back 删除末尾的最后一个元素，但是操作过后容量不会收到影响
//shrink_to_fit 删除多余空间
//clear 清空所有元素，不释放空间
//emplace_back表示的是会在vector 对象所属的这块内存空间中，调用对应的类的构造函数，创建对象，没有栈对象的创建过程
```

##### Vector的常用操作

```C++
iterator begin();  //返回首位迭代器
iterator end();  //返回尾后迭代器

bool empty() const; //判空

size_type size() const; //返回容器中存放的元素个数
size_type capacity() const; //返回容器容量（最多可以存放元素的个数）

void push_back(const T& value); //在最后一个元素的后面再存放元素
void emplace_back( Args&&... args );//在最后一个元素的后面构造一个新的对象，只需要传递需要创建对象的构造函数参数即可

void pop_back(); //删除最后一个元素
void clear(); //清空所有元素，但不释放空间
void shrink_to_fit();  //释放多余的空间

void reserve(size_type new_cap);//申请空间，不存放元素
```

```C++
#include <iostream>
#include <vector>
using std::cout;
using std::endl;
using std::cin;
using std::vector;
void test(){

    vector<int> v={1,2,3,4,5};
    auto it=v.begin();
    auto it2=v.end()-1;
    cout<<"首元素:"<<*it<<" "<<"尾元素:"<<*it2<<endl;
    cout<<"vector是否为空:"<<v.empty()<<endl;
    cout<<"vector中的元素个数:"<<v.size()<<endl;
    cout<<"容量:"<<v.capacity()<<endl;
    v.push_back(6);
    v.push_back(7);//再最后一个元素的后面存放元素
    cout<<"vector中的元素个数:"<<v.size()<<endl;
    v.pop_back();//删除最后一个元素
    cout<<"vector中的元素个数:"<<v.size()<<endl;
    cout<<"容量:"<<v.capacity()<<endl;
    v.shrink_to_fit();//释放多余空间
    cout<<"容量:"<<v.capacity()<<endl;
    v.clear();//清空所有元素，但不释放空间
    cout<<"vector中的元素个数:"<<v.size()<<endl;
    cout<<"容量:"<<v.capacity()<<endl;
}

int main()
{
 test();
 return 0;
}

```

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250710195018596.png" alt="image-20250710195018596" style="zoom:80%;" />

##### vector的遍历

```C++
Vector<int> num{1,2,3,4,5};
//1.下标遍历
for(int i=0;i<num.size();i++){
    cout<<num[i]<<endl;
}

//2.for增强遍历
for(auto &i:num){
    cout<<i<<endl;
}

//3.迭代器遍历
auto it=num.begin();
while(it!=num.end()){
    cout<<*it<<endl;
    it++;
}
```

##### vector的动态扩容

当vector容器放满后会动态扩容vector的大小，在GCC平台以2倍扩容，在MSVC平台以1.5倍扩容。

其工作步骤如下：

（1）开辟空间

（2）Allocator分配（后面STL阶段学习）

（3）复制，再添加新元素

（4）回收原空间

##### vector的底层实现

无论vector里面有没有存放元素，其实大小始终是24字节。24字节其实是三个指针的大小，一个指向开始，一个指向所存元素的末尾，一个指向当前容量的结尾。

![image-20250710200141370](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250710200141370.png)

<span style=color:red;background:yellow>**_start指向当前数组中第一个元素存放的位置**</span>

<span style=color:red;background:yellow>**_finish指向当前数组中最后一个元素存放的下一个位置**</span>

<span style=color:red;background:yellow>**_end_of_storage指向当前数组能够存放元素的最后一个空间的下一个位置**</span>
