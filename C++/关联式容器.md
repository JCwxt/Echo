# 关联式容器

#### 1.set

##### set的使用

1.set中不允许出现重复的元素

2.set中的元素默认会进行从小到大的顺序排序。

##### set的构造

1.无参构造

```C++
set<int> number1;
```

2.标准初始化列表构造

```C++
set<int> number2={1,2,4,3,5,6};
```

3.迭代器方式构造，传入一个first迭代器，传入一个last迭代器

```C++
set<int> number3(number2.begin(),number2.end());
```

4.拷贝构造

```C++
set<int> number4=number2;
```



##### set的查找

**count：**返回的是个数：set不允许重复，所以要么是0要么是1.

**find:** 返回的是迭代器，如果找到了返回相应元素的迭代器，如果没有找到就返回end尾迭代器。

```C++
void test2(){
    set<int> number={1,3,5,7,9,2,4,6,8,10};
    cout<<number.count(1)<<endl;
    cout<<number.count(101)<<endl;
    auto result=number.find(1);
    if(result==number.end()){
        cout<<"没有找到该元素"<<endl;
    }else{
        cout<<"找到了该元素"<<*result<<endl;
    }
}
```

![image-20250718141828148](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250718141828148.png)

##### set的插入

**insert:**   返回的是一个pair<iteritor,bool>.

第一个参数表示的是插入成功或者阻止插入的这个元素的迭代器。

第二个参数表示是否插入成功。

**插入单个元素**

```C++
void test3(){
    set<int> num={1,2,4,3};
    pair<set<int>::iterator ,bool> result=num.insert(5);
    if(result.second){
        cout<<"插入成功"<<*(result.first)<<endl;
    }else{
        cout<<"插入失败"<<endl;
    }
}
```

![image-20250718171901166](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250718171901166.png)

**插入多个元素**

- 传入两个迭代器，插入两个迭代器范围内的元素。

- 传入大括号列表，插入列表中的元素。

```C++
void test4(){
    set<int> num={1,3,2};
    int arr[]={4,5,6};
    num.insert(arr,arr+3);
    print(num);
    num.insert({7,9,8});
    print(num);
}
```

![image-20250718172401340](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250718172401340.png)

<span style=color:red;background:yellow>**注意：**</span>

- **set容器不支持下标访问**，因为没有operator[] 重载函数

- **不能通过set的迭代器直接修改key值**，set的底层实现是红黑树，结构稳定，不允许直接修改。

#### 2.map

map中存储的是一系列的键值对。

元素唯一：创建map对象时，key值相同的元素会被舍弃，key不同即使value相同也可以保留。

默认以key值的参考进行升序排列

##### map的构造

1.以大括号参数列表的形式初始化

```c++
map<int,string> num={{1,"Hello"},{2,"world"}};
```

2.以pair的形式

```C++
map<int,string> num={
       pair<int,string>(3,"hhhh"),
       pair<int,string>(4,"xxxx")
}
```

3.以make_pair的形式

```C++
map <int,string> num={
    make_pair(5,"shenzhen"),
    make_pair(6,"beijing")
}
```

```C++
#include <iostream>
#include <string>
#include <map>
#include <utility>
using std::string;
using std::map;
using std::make_pair;
using std::pair;
using std::cout;
using std::endl;
using std::cin;
void print(const map<int,string> &m);
void test(){
    map <int,string> num={
        {1,"C++"},
        {2,"C"},
        pair<int,string>(3,"Java"),
        pair<int,string>(4,"Python"),
        make_pair(5,"GO"),
        make_pair(6,"PHP")
    };
    print(num);
}
void print(const map<int,string> &m){
    for(auto i:m){
        cout<<i.first<<","<<i.second<<endl;
    }
}

int main()
{
 test();
 return 0;
}

```

##### ![image-20250718174314755](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250718174314755.png)

##### **map的查找**

根据key值在map中进行查找

count函数的返回值：如果找到返回1，如果没找到返回0（size_t类型）

find函数的返回值：如果找到返回相应元素的迭代器，如果没找到返回end( )的结果。

```C++
 //map的查找
    cout<<num.count(5)<<endl;
    cout<<num.count(9)<<endl;
    auto result=num.find(5);
    if(result!=num.end()){
        cout<<"查找到元素"<<endl;
        cout<<result->first<<"  "<<result->second<<endl;
    }else{
        cout<<"查找失败"<<endl;
    }
```

![image-20250718175638834](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250718175638834.png)

**map的插入**

插入单个元素，此时insert函数的返回值是一个pair（第一个对象成员是map元素相应的迭代器，第二个对象成员是bool值）。

```C++
 num.insert({7,"JSP"});
    num.insert({7,"hhhh"});
    num.insert(make_pair(8,"C#"));
    num.insert(pair<int,string>(9,"JavaScript"));
    print(num);
```

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250718192843106.png" alt="image-20250718192843106" style="zoom:67%;" />

插入一组数据

```C++
    map<int,string> city={{1,"beijing"},{2,"shanghai"}};
    //采用迭代器的方式
    num.insert(city.begin(),city.end());
    //参数列表的形式
    city.insert({{3,"nanjing"},{4,"wuhan"}});
    print(city);
    cout<<"=========================="<<endl;
    print(num);
```

##### map的下标操作

map的下标指的是key的值，所以不仅可以传递数字，还可以传递其它数据类型。

```c++
 map <int,string> num={
        {1,"C++"},
        {2,"C"},
        pair<int,string>(3,"Java"),
        pair<int,string>(4,"Python"),
        make_pair(5,"GO"),
        make_pair(6,"PHP")
    };
 cout<<num[0]<<endl;//此时并不会输出map中的第一个元素，下标指的是map中的key,因为map中没有key=0的元素，故输出空。
 cout<<num[1]<<endl;//输出 c++
```

调用了map下标操作之后，如果传入了一个不存在的key，那么会将这个key和空的value插入到map中。

下标访问可以进行写操作,只是对value进行写操作，不影响排序。

```c++
  num[9];
  num[10]="C#";//新增一个元素
  num[6]="JavaScript";
```

![image-20250718193726424](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250718193726424.png)

