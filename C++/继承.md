# 继承

### 基本概念

如果希望能够复用之前类的代码功能，除了重写之外，还可以继承原来的类，那么便可以获取这个类的特性。

被继承的类称之为父类，基类。

继承父类的类称之为子类，派生类。

**定义一个派生类的过程**

1.吸收基类成员

2.添加新的成员（非必须）

3.隐藏基类的成员（非必须）

如果定义了一个派生类只写了继承关系，没有写任何自己的东西，那么也会吸收基类的成员，这种情况叫做空派生类。

#### 三种不同继承方式之间的区别

- **公有继承（public）**：基类的公有成员（public）和保护成员（protected）在派生类里保持原有的访问级别。
- **保护继承（protected）**：基类的公有成员和保护成员在派生类中都变成保护成员。
- **私有继承（private）**：基类的公有成员和保护成员在派生类中都变成私有成员。

![image-20250720141516335](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250720141516335.png)

**<font color='red'>总结：</font>**

1. 不管什么继承方式，派生类内部除了基类的私有成员不可以访问，其他的都可以访问；
2. 不管什么继承方式，派生类对象在类外除了公有继承基类中的公有成员可以访问外，其他的都不能访问。

##### 保护继承和私有继承的区别

保护继承和私有继承在两代继承时没有区别，二者在类外的派生类对象都不可访问到基类成员。但是在第三代继承时，如果中间层使用的是protected继承，那么第三代继承在派生类内部依旧可以访问到顶层基类的成员。如果中间层使用的是private继承，那么在第三代继承的派生类中将无法访问到顶层基类的成员。

如果继承层次中都采用的是保护继承，任意层次都可以访问顶层基类的非私有成员；但如果采用私有继承之后，这种特性会被打断。

#### 继承关系的局限性

创建、销毁的方式不能被继承 —— 构造、析构

复制控制的方式不能被继承 —— 拷贝构造、赋值运算符函数

空间分配的方式不能被继承 —— operator new 、 operator delete

友元不能被继承（友元破坏了封装性，为了降低影响，不允许继承

#### 继承语法规则

**创建派生类对象，绝对会先调用派生类的构造函数，随后去调用基类的构造函数。**

1.当派生类中没有显示调用基类的构造函数时，会默认调用基类的无参构造函数。

2.如果基类没有默认无参构造，子类构造函数的初始化列表中也没有显示调用基类的构造函数，编译器会报错。

3.当派生类对象调用基类构造函数时，希望使用非默认的基类构造函数，必须显示的在初始化列表中写成。

**总结：**

创建派生类对象时，一定会先调用基类的构造函数，如果没有默认的构造函数，并且也没有主动调用，则会出错。

```C++
#include <iostream>
using std::cout;
using std::endl;
using std::cin;
class Point{
public:
    Point(int x,int y)
    :_x(x)
    ,_y(y)
    {
        cout<<"Point(int,int)"<<endl;
    }
    ~Point(){
        cout<<"~Point()"<<endl;
    }
    void print(){
        cout<<"("<<_x<<","<<_y<<")"<<endl;
    }
    int _x;
    int _y;
};
class Point3D:public Point{
public:
    Point3D(int x,int y,int z)
    :Point(x,y)
    ,_z(z)
    {
      cout<<"Point3D(int,int,int)"<<endl;
    }
    void print(){
        cout<<"("<<_x<<","<<_y<<","<<_z<<")"<<endl;
    }
    ~Point3D(){
        cout<<"~Point3D"<<endl;
    }
private:
    int _z;
};
void test(){
    Point3D p(10,20,30);
    p.print();
}
int main()
{
 test();
 return 0;
}

```

![image-20250720150025456](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250720150025456.png)

**<font color='red'>创建派生类对象会马上调用派生类的构造函数，但是在初始化列表的最开始调用基类的构造函数。</font>**

**<font color='red'>当派生类析构函数执行完毕之后，会自动调用基类析构函数，完成基类部分所需要的销毁。</font>**

#### 继承体系下的内存布局

```C++
void test{
    cout<<sizeof(Point3D)<<endl;
    cout<<sizeof(Point)<<endl;
}
```

![image-20250720150317340](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250720150317340.png)

**思考：Point3D中只有一个数据成员，为什么结果会是12？**

因为派生类会吸收基类的数据成员，内存排列上面基类在前，派生类在后。调用基类构造函数的目的是给派生类对象中的基类成员子对象的部分进行初始化。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250720150710078.png" alt="image-20250720150710078" style="zoom: 50%;" />

**思考：如果此时派生类中包含一个对象数据成员，那么此时的内存布局又该如何？**

```c++
class Object{

    int a;
    double b;
};
class Point3D:public Point{
public:
    Point3D(int x,int y,int z)
    :Point(x,y)
    ,_z(z)
    {
      cout<<"Point3D(int,int,int)"<<endl;
    }
    void print(){
        cout<<"("<<_x<<","<<_y<<","<<_z<<")"<<endl;
    }
    ~Point3D(){
        cout<<"~Point3D"<<endl;
    }
private:
    Object o;
    int _z;
};
```

```C++
void test{
    cout<<sizeof(Point3D)<<endl;//32
    cout<<sizeof(Point)<<endl;//8
}
```

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250720152338507.png" alt="image-20250720152338507" style="zoom:50%;" />

#### **对基类成员的隐藏**

派生类中声明了和基类的数据成员<span style=color:red;background:yellow>**同名**</span>的数据成员，就会对基类的这个数据成员形成隐藏。

派生类对象无法通过数据成员的名字直接访问基类的这个数据成员。可通过类名加作用域限定符的方法访问。

#### 对基类成员函数的隐藏

当派生类声明了与基类同名的成员函数时，只要名字相同，即使参数列表不同，也只能看到派生类部分的，无法通过派生类对象直接调用基类的同名函数。

如果一定要调用基类的这个成员函数，需要加上作用域，但是这种写法不符合面向对象的原则，不推荐实际使用。

### 多继承

```C++
class A
{
public:
    A(){ cout << "A()" << endl; }
    ~A(){ cout << "~A()" << endl; }
    void print() const{
        cout << "A::print()" << endl;
    }
};

class B
{
public:
    B(){ cout << "B()" << endl; }
    ~B(){ cout << "~B()" << endl; }
    void show() const{
        cout << "B::show()" << endl;
    }
};

class C
{
public:
    C(){cout << "C()" << endl; }
    ~C(){ cout << "~C()" << endl; }
    void display() const{
        cout << "C::display()" << endl;
    }
};

class D
: public A,B,C
{
public:
    D(){ cout << "D()" << endl; }
    ~D(){ cout << "~D()" << endl; }
}
```

但是此时D只是对A进行public继承，对B,C是私有继承。如果想要实现D对A，B，C的公有继承如何实现？

```C++
class D:public A,public B,public C{ };
```

**思考：此时创建D对象时的构造函数调用以及析构函数的调用如何执行？**

创建D对象时，会先调用D的构造函数，然后按照继承顺序依次调用相应的构造函数，调用A,B,C的构造函数。

在销毁时，也是首先调用D的析构函数，在按照继承的声明顺序的相反顺序，依次调用析构函数。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250720154143745.png" alt="image-20250720154143745" style="zoom: 67%;" />

#### 多继承可能引发的问题

##### 1.成员名访问的二义性

如果在A,B,C类中都定义一个print()函数，再让D类继承A,B,C，此时通过D的对象去访问print()时就会造成二义性，不知道访问哪一个print()。

解决成员名访问冲突的方法：加类作用域（不推荐）—— 应该尽量避免。

同时，<span style=color:red;>**如果D类中声明了同名的成员，可以对基类的这些成员造成隐藏效果**</span>，那么就可以直接通过成员名进行访问。

##### 2.存储二义性的问题

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250720154801074.png" alt="image-20250720154801074" style="zoom:67%;" />

D类对象的创建会生成一个B类子对象，其中包含一个A类子对象；还会生成一个C类子对象，其中也包含一个A类子对象。所以D类对象的内存布局中有多个A类子对象，访问继承自A的成员时会发生二义性。****

因为编译器需要通过基类子对象去调用，但是不知道应该调用哪个基类子对象的成员函数。

<span style=color:red;>**解决存储二义性的方法：中间层的基类采用虚继承顶层基类的方式解决存储二义性**</span>

#### 基类和派生类对象之间的转换（五星）

**一般情况下，基类对象占据的空间小于派生类对象。**

（空继承时，有可能相等）

1：可否把一个基类对象赋值给一个派生类对象？可否把一个派生类对象赋值给一个基类对象？

2：可否将一个基类指针指向一个派生类对象？可否将一个派生类指针指向一个基类对象？

3：可否将一个基类引用绑定一个派生类对象？可否将一个派生类引用绑定一个基类对象？



``` c++
Base base = d1; //ok
Derived d1 = base; //error

Base * pbase = &d1; //ok
Derived * pderived = &base //error
    
Base & rbase = d1; //ok
Derived & rderived = base; //error
```

> 以上三个ok的操作，叫做向上转型（往基类方向就是向上），向上转型是可行的，**反之，基类向派生类转型称为向下转型，直接进行向下转型都会报错。**
>
> - 用基类对象接受派生类对象的赋值（ok） 
> - 用基类引用绑定派生类对象（ok）
> - 用基类指针指向派生类对象（ok）
>
> **—— 体现派生类向基类的转型。**



向下转型有风险（如下）—— 以指针为例

<img src="D:/卓面/4th/05_CppBase/C++讲义/7.继承.assets/image-20231102164339873.png" alt="image-20231102164339873" style="zoom:80%;" />

Base类的指针指向Derived类的对象，d1对象中存在一个Base类的基类子对象，这个Base类指针所能操纵只有继承自Base类的部分，不会存在越界风险；

Derived类的指针指向Base对象，除了操纵Base对象的空间，还可以操纵一片额外空间，**只能是非法空间**，所以会报错。

<img src="D:/卓面/4th/05_CppBase/C++讲义/7.继承.assets/image-20240527173118490.png" alt="image-20240527173118490" style="zoom:67%;" />

> <span style=color:red;background:yellow>**补充：**</span>基类对象和派生类对象之间的转换同理，但是没有太大的意义，**基类指针指向派生类对象（基类引用绑定派生类对象）重点掌握，只能访问到基类的部分。**

> - <font color=red>**有些场景下，向下转型是合理的，可以使用static_cast来进行转换。**</font>
>
> 即基类向派生类的转型，我们看看这样的例子
>
> ``` c++
> Base base;
> Derived d1;
> 
> Base * pbase = &d1;
> Derived * pderived = pbase;//这种转型是合理的，但是不能直接转型，会报错
> ```
>
> <img src="D:/卓面/4th/05_CppBase/C++讲义/7.继承.assets/image-20240527181643868.png" alt="image-20240527181643868" style="zoom:67%;" />

> <span style=color:red;background:yellow>**结论：**</span>
>
> **可以用派生类对象赋值给基类对象（用基类对象接受派生类对象的赋值），可以用基类指针指向派生类对象，可以用基类引用绑定派生类对象。**
>
> **反之不可。**

#### 继承体系下的复制控制函数（五星）

当派生类中没有显示定义复制控制函数，就会自动完成基类部分的复制控制操作。

当派生类中有显式定义复制控制函数，自动完成基类部分的复制控制函数调用。
