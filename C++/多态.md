# 多态

同一段代码在不同的环境运行，有不同的效果。即同一方法作用在不同的对象上会有不同的行为。

**编译时多态（静态绑定）：**在编译阶段就确定了函数调用的地址。像普通成员函数、函数重载、模板实例化等，采用的都是静态绑定。

**运行时多态（动态绑定）：**函数调用的地址要到运行时才能确定。这依赖于对象的实际类型，而非指针或引用的类型。动态绑定是实现多态的关键所在。

| **特性**     | **静态多态（模板 / 重载）** | **动态多态（虚函数）**   |
| ------------ | --------------------------- | ------------------------ |
| **决议时机** | 编译时                      | 运行时                   |
| **实现方式** | 模板、函数重载              | 虚函数、继承             |
| **性能**     | 无运行时开销                | 虚函数表查找（轻微开销） |
| **灵活性**   | 编译时确定，无法动态变更    | 运行时可动态切换实现     |
| **代码膨胀** | 可能生成多个模板实例        | 单份代码，通过虚表调度   |

#### 多态的底层原理

多态的底层原理是通过**<font color='red'>虚函数</font>**来实现的。

**虚函数：**在基类中使用**virtual**关键字进行声明的成员函数，能够在派生类中被重写（**override**）。当通过基类指针或引用调用虚函数时，会触发动态绑定。

当加上Virtual关键字后，创建对象会比没有加之前多出8个字节的大小，即一个指针的长度，这个指针就是虚函数指针。虚函数指针指向了虚函数表（虚表）。

**虚函数表：**

- 每个包含虚函数的类都会有一个虚函数表，它是一个存储虚函数地址的静态数组。

- 每个对象的内存布局里都包含一个指向所属类虚函数表的指针（vptr）。

- 当类被继承时，派生类会继承基类的虚函数表。要是派生类重写了某个虚函数，那么虚函数表中对应的条目就会被更新为派生类的函数地址。

**多态的实现过程：**

```C++
class Base{
public:
    virtual void print(){
        cout<<"Base"<<endl;
    }
};
class Derived:public Base{
public:
    void print(){
        cout<<"Derived"<<endl;
    }
};
void test(){
    Base *pbase=new Derived();
    pbase->print();
}
```

如果此时Base中的print()函数没有加上virtual关键字，此时pbase-->print()调用的就是基类的成员函数。

因为将一个基类的指针，指向派生类时，此时基类指针所能访问的部分只有基类部分。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250721175451007.png" alt="image-20250721175451007" style="zoom:50%;" />

当加上virtual关键字后，此时pbase-->print()调用的就是派生类的成员函数，此时这个现象就称为多态。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250721191332741.png" alt="image-20250721191332741" style="zoom: 50%;" />

1.当基类中成员函数标注为虚函数后，此时基类对象和派生类对象的内存布局都会发生变化，都会多出来一个指针大小的内存空间，这个指针就是**虚函数指针**。

2.虚函数指针指向了一张存储了虚函数的入口地址的表，即**虚函数表。**虚函数真正存放的地址在程序代码区。

3.**派生类继承基类，会继承基类的虚函数表**。虚函数表里的内容和基类的虚函数表的内容是一样的，但是派生类的虚函数指针，指向的是自己的虚函数表。

4.如果在派生类中对基类的虚函数进行了重写，那么便会在派生类中的虚函数表中覆盖原先基类虚函数的入口地址。

5.如果最终使用一个基类指针指向派生类对象，并且利用基类指针去调用虚函数时，此时会先查找虚函数指针====>查找虚函数表，获取到虚函数的入口地址======>再去程序代码区中找到对应的函数，进行调用。

------



#### 动态多态激活的条件（五星）

##### 覆盖override

如果一个基类的成员函数定义为虚函数，那么它在所有派生类中也保持为虚函数，即使在派生类中省略了virtual关键字，也仍然是虚函数。覆盖指的是虚函数表中覆盖了虚函数的地址。**<font color='red'>要求：返回值，函数名称，函数参数类型，参数个数均相同。</font>**

**动态多态激活的条件要求：**

1. 基类定义虚函数
2. <font color='red'>**派生类中要覆盖虚函数**</font>（覆盖的是虚函数表中的地址信息）
3. 创建派生类对象
4. **基类的指针指向派生类对象**
5. <font color='red'>**通过基类指针（引用）调用虚函数**</font>

------

**override关键字的作用：**

在虚函数的函数参数列表之后，函数体的大括号之前，加上override关键字，告诉编译器此处定义的函数是要对基类的虚函数进行覆盖。

**思考：覆盖，函数重载，隐藏之间的关联？**

覆盖：发生在基类和派生类之间，虚函数进行覆盖重写机制，派生类覆盖重写基类的虚函数。

函数重载：发生在一个类中的不同成员函数，函数名称相同，但是参数不同。

隐藏：发生在派生类和基类之间，基类和派生类定义了相同名称的函数，即可发生隐藏。

**Question:一个类中虚函数表有几张？**

0：如果基类和派生类中没有虚函数，那么此时虚函数表只有0张。

1：基类中有虚函数，派生类继承基类，也会拥有虚函数，此时只有一张虚函数表。

多个：继承多个带有虚函数的类时，此时有多张虚函数表。

##### 虚函数的限制

**1.构造函数不能设为虚函数**

构造函数的作用是创建对象时完成数据的初始化，而虚函数机制被激活的条件之一就是要先创建对象，有了对象才能表现出动态多态。如果将构造函数设为虚函数，那此时构造未执行完，对象还没完成初始化，存在矛盾。

**2.静态成员函数不能设为虚函数**

虚函数的实际调用：  <span style=color:red;background:yellow> this -> vfptr -> vtable -> virtual function</span>，但是静态成员函数没有this指针，所以无法访问到vfptr

vfptr是属于一个特定对象的部分，虚函数机制起作用必然需要通过vfptr去间接调用虚函数。静态成员函数找不到这样特定的对象。

**3.Inline函数不能设为虚函数**

因为inline函数在编译期间完成替换，而在编译期间无法展现动态多态机制，所以起作用的时机是冲突的。如果同时存在，inline失效。

**4.普通函数不能设为虚函数**

虚函数要解决的是对象多态的问题，与普通函数无关，普通函数式非成员函数，不能设置为虚函数。

##### 虚函数调用场景分析（三星）

**1.通过对象直接调用**

**此时就是普通函数调用**，不满足动态多态的激活条件，也不会走虚函数。多态被激活肯定需要走虚函数表，但是走虚函数表不一定动态多态被激活，例如在派生类中没有对虚函数进行覆盖。

**2.在构造函数和析构函数中访问虚函数**

```C++
class Grandpa
{
public:
    Grandpa(){ cout << "Grandpa()" << endl; }
    ~Grandpa(){ cout << "~Grandpa()" << endl; }

    virtual void func1() {
        cout << "Grandpa::func1()" << endl;
    }

    virtual void func2(){
        cout << "Grandpa::func2()" << endl;
    }
};

class Parent
: public Grandpa
{
public:
    Parent(){
        cout << "Parent()" << endl;
        func1();//构造函数中调用虚函数
    }

    ~Parent(){
        cout << "~Parent()" << endl;
        func2();//析构函数中调用虚函数
    }
};

class Son
: public Parent
{
public:
    Son() { cout << "Son()" << endl; }
    ~Son() { cout << "~Son()" << endl; }

    virtual void func1() override {
        cout << "Son::func1()" << endl;
    }

    virtual void func2() override{
        cout << "Son::func2()" << endl;
    }
};

void test(){
    Son ss;
    Grandpa * p = &ss;
    p->func1();
    p->func2();
}
```

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250721195329003.png" alt="image-20250721195329003" style="zoom:50%;" />

此时代码的执行结果如上图所示，代码的内存图示如下所示。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250721195355010.png" alt="image-20250721195355010" style="zoom: 50%;" />

在parent的构造函数执行时，并不知道是在构造Son的对象，在此过程中，**只能看到本层及以上的部分**（因为Grandpa类的基类子对象已经创建完毕，虚表中记录了Grandpa::func1和func2的地址）

在Parent的析构函数执行时，此时Son的析构函数已经执行完了，可以理解为Son需要进行的回收工作都已经结束了。所以Parent的析构函数**也只能看到本层及以上的部分**。

<font color=red>**——如果Parent类中也覆盖了func1和func2，那么会调用Parent本层的虚函数。**</font>

<span style=color:red;background:yellow>**总结：**</span>

C++标准规定，**在构造函数和析构函数中**，通过`this`指针（隐式或显式）调用的虚函数会被解析为当前类（即构造函数或析构函数所属的类）的版本，而不是通过虚函数表来动态解析。

3. **在普通成员函数中调用虚函数**

``` c++
class Base{
public:
    Base(){
        cout << "Base()" << endl;
    }

    virtual void print(){
            cout << "Base::print" << endl;
        }

    //隐含的this指针   Base * const this
    // Base * const this = &Derived;
    // this->fun1();
    // Base * const this = pbase2; 多态
    void fun1(){
        this->print();
    }

    void fun2(){
        Base::print();
    }

};

class Derived
:public Base
{
public:
    Derived(){
        cout << "Derived()" << endl;
    }

    void print(){
        cout << "Derived::print" << endl;
    }
};

void test(){
    Base base;
    Derived derived;
    base.fun1();//(1)
    base.fun2();//(2)

    derived.fun1();//(3)
    derived.fun2();//(4)

    cout << "============" << endl;

    Base * pbase = &base;
    pbase->fun1();//(5)
    pbase->fun2();//(6)
    cout << "------------------" << endl;
    Base * pbase2 = &derived;
    pbase2->fun1();//(7)
    pbase2->fun2();//(8)
}
```

test函数中前4次的调用中其中1、2、4均不涉及到多态，因为不满足父类指针(引用)指向子类的模式，3满足多态的特性。5和6的调用也是不符合多态的特性，7符合多态的特性，8不符合多态特性。

#### 抽象类（四星）

##### 1.声明了纯虚函数的类

**纯虚函数**是一种特殊的虚函数，在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，**它的实现留给该基类的派生类去做**。这就是纯虚函数的作用。纯虚函数的格式如下：

``` c++
class 类名 {
public:
	virtual 返回类型 函数名(参数 ...) = 0;
};
```

多个派生类可以对纯虚函数进行多种不同的实现，但是都需要遵循基类给出的接口（纯虚函数的声明）。

<span style=color:red;>**声明了纯虚函数的类成为抽象类，抽象类不能实例化对象。**</span>

抽象类虽然无法创建对象，但是可以定义此类型的指针，指向派生类对象，去调用实现好的纯虚函数。

```C++
#include <string>
#include <iostream>
using std::string;
using std::cout;
using std::endl;
using std::cin;
class Animal{
public:
    virtual void AnimalSound()=0;
};
class Cat:public Animal{
public:
    Cat(string name)
    :_name(name)
    {}
    virtual void AnimalSound(){
        cout<<_name<<":"<<"喵喵喵喵"<<endl;
    }
private:
    string _name;
};
class Dog:public Animal{
public:
    Dog(string name)
    :_name(name)
    {}

    virtual void AnimalSound(){
        cout<<_name<<":"<<"汪汪汪"<<endl;
    }
private:
    string _name;
};
void test(){

    Animal *d=new Dog("小狗");
    Animal *c=new Cat("小猫");
    d->AnimalSound();
    c->AnimalSound();
}

int main()
{
 test();
 return 0;
}

```

![image-20250721202114839](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250721202114839.png)

##### 2.定义了protected类型的构造函数的类

如果一个类只定义了protected型的构造函数而没有提供public构造函数，无论是在外部还是在派生类中作为其对象成员都不能创建该类的对象，但可以由其派生出新的类，这种能派生新类，却不能创建自己对象的类是另一种形式的抽象类。

```C++
class Base {
protected:
	Base(int base)
    : _base(base) 
    { 
        cout << "Base()" << endl; 
    }

	int _base;
};
class Derived
: public Base {
public:
	Derived(int base, int derived)
	: Base(base)
	, _derived(derived)
	{ cout << "Derived(int,int)" << endl; }
    
	void print() const
	{
		cout << "_base:" << _base
		<< ", _derived:" << _derived << endl;
	}
private:
	int _derived;
};

```

Base类只定义了protected属性的构造函数，不能创建Base类的对象，但是可以定义Base类的指针—— Base类是抽象类

```C++
Base b(1);//error
Derived d(1,2);
Base *p=&d;//ok
```

如果Derived类也只定义了protected属性的构造函数，Derived类也是抽象类，无法创建对象，<span style=color:red;background:yellow>**但是可以定义指针指向派生类对象**</span>

```C++
Derived d(1,2);//error
class C:public Derived{
    
}
C c;
Deriver *pderived=c;//ok
```

那么还需要再往下派生，一直到某一层提供了public的构造函数，才能创建对象。

如果派生类中基类成员子对象也无法创建成功。

```C++
class Derived
: public Base {
public:
	Derived(int base, int derived,Base base)
	: Base(base)
	, _derived(derived)
    ,_base(base)//调用Base构造函数创建成员子对象，error
	{ cout << "Derived(int,int)" << endl; }
    
	void print() const
	{
		cout << "_base:" << _base
		<< ", _derived:" << _derived << endl;
	}
private:
	int _derived;
    Base _base;
};

```



##### <font color='red'>析构函数设置为虚函数（五星）</font>

```C++
#include <string>
#include <iostream>
using std::string;
using std::cout;
using std::endl;
using std::cin;
class Animal{
public:
    virtual void AnimalSound()=0;
    virtual ~Animal(){
        cout<<"Animal"<<endl;
    }
};
class Cat:public Animal{
public:
    Cat(string name)
    :_name(name)
    {}
    virtual void AnimalSound(){
        cout<<_name<<":"<<"喵喵喵喵"<<endl;
    }
    ~Cat(){
        cout<<"Cat"<<endl;
    }
private:
    string _name;
};
class Dog:public Animal{
public:
    Dog(string name)
    :_name(name)
    {}

    virtual void AnimalSound(){
        cout<<_name<<":"<<"汪汪汪"<<endl;
    }
    ~Dog(){
        cout<<"Dog"<<endl;
    }
private:
    string _name;
};
void test(){
    Animal *d=new Dog("小狗");
    Animal *c=new Cat("小猫");
    d->AnimalSound();
    c->AnimalSound();

    delete d;
    delete c;
}

int main()
{
 test();
 return 0;
}

```

![image-20250721205010821](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250721205010821.png)

为了让基类指针能够调用派生类的析构函数，需要将Animal的析构函数也设为虚函数。

Cat类和Dog类中发生虚函数的覆盖，将Cat和Dog的虚函数表中记录的虚函数地址改变了。析构函数尽管不重名，也认为发生了覆盖。

在派生类析构函数执行完毕后，会自动调用基类析构函数。这是由编译器在析构函数调用序列中隐式安排的，这个过程不依赖于虚函数表，属于C++的语言规则。

总结：

<span style=color:red;>**在实际的使用中，如果有通过基类指针回收派生类对象的需求，都要将基类的析构函数设为虚函数。**</span>

建议：一个类定义了虚函数，而且需要显示定义析构函数，就将它的析构函数设为虚函数。



#### 带虚函数的多继承

```C++
class Base1{
public:
    Base1()
    :_iBase1(10)
    {
        cout << "Base1()" << endl;
    }

    virtual void f(){
        cout << "Base1::f()" << endl;
    }

    virtual void g(){
        cout << "Base1::g()" << endl;
    }

    virtual void h(){
        cout << "Base1::h()" << endl;
    }

    virtual ~Base1(){
        cout << "~Base1()" << endl;
    }

private:
    double _iBase1;
};

class Base2{
    public:
        Base2()
        :_iBase2(20)
        {
            cout << "Base2()" << endl;
        }
    
        virtual void f(){
            cout << "Base2::f()" << endl;
        }
    
        virtual void g(){
            cout << "Base2::g()" << endl;
        }
    
        virtual void h(){
            cout << "Base2::h()" << endl;
        }
    
        virtual ~Base2(){
            cout << "~Base2()" << endl;
        }
    
    private:
        double _iBase2;
};

class Base3{
    public:
        Base3()
        :_iBase3(30)
        {
            cout << "Base3()" << endl;
        }
    
        virtual void f(){
            cout << "Base3::f()" << endl;
        }
    
        virtual void g(){
            cout << "Base3::g()" << endl;
        }
    
        virtual void h(){
            cout << "Base3::h()" << endl;
        }
    
        virtual ~Base3(){
            cout << "~Base3()" << endl;
        }
    
    private:
        double _iBase3;
};

class Derived 
	: public Base1
	, public Base2
	, public Base3
{
public:
	Derived()
	: _iDerived(10000) 
	{ cout << "Derived()" << endl; }

	void f() override
	{
		cout << "Derived::f()" << endl;
	}

	void g1()
	{
		cout << "Derived::g1()" << endl;
	}
private:
	double _iDerived;
};

int main(void)
{
	cout << sizeof(Derived) << endl;

	Derived d;
	Base1* pBase1 = &d;
	Base2* pBase2 = &d;
	Base3* pBase3 = &d;

	cout << "&Derived = " << &d << endl; 
	cout << "pBase1 = " << pBase1 << endl; 
	cout << "pBase2 = " << pBase2 << endl; 
    cout << "pBase3 = " << pBase3 << endl; 

	return 0;
}
```

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250722172235136.png" alt="image-20250722172235136" style="zoom:50%;" />

此时代码的内存图示如下：

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250727182623609.png" alt="image-20250727182623609" style="zoom: 50%;" />

VS中验证的内存如下：

<img src="C:\Users\34078\Pictures\virtual.png" style="zoom:67%;" />

#### 虚拟继承

虚拟继承是一种特殊的继承方式，用于**解决菱形继承中的冗余性和二义性问题**。

##### 1.虚拟继承无虚函数

```C++
class Base {
public:
    void f() {
        cout << "Base" << endl;
    }
private:
    double _base1;
};
class Derived :virtual Base {
public:
    void g() {
        cout << "Derived" << endl;
    }
private:
    double _derived;
};
```

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250722193847673.png" alt="image-20250722193847673" style="zoom:67%;" />

**虚拟继承相较与普通继承有什么特征：**

1.普通继承是基类在前，派生类在后，但是虚拟继承是派生类在前，虚基类在后。

2.在派生类中会多出来一个虚基指针，去指向虚基表。虚基表中存储了两个偏移量，一个是距离当前类的偏移量，一个是距离虚基类的偏移量。

**为什么需要虚基指针去指向虚基表？**

为了快速访问到虚基类。

##### 2.虚拟继承带虚函数

```C++
class Base {
public:
    virtual void f() {
        cout << "Base" << endl;
    }
private:
    double _base1;
};
class Derived :virtual Base {
public:
    void g() {
        cout << "Derived" << endl;
    }
private:
    double _derived;
};
```

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250722195524646.png" alt="image-20250722195524646" style="zoom:67%;" />

##### 3.虚拟继承带虚函数，并且派生类也有虚函数

```C++
class Base {
public:
    virtual void f() {
        cout << "Base" << endl;
    }
private:
    double _base1;
};
class Derived :virtual Base {
public:
   virtual void g() {
        cout << "Derived" << endl;
    }
private:
    double _derived;
};
```

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250722195908971.png" alt="image-20250722195908971" style="zoom:67%;" />

此时派生类中会多出来一个虚函数指针，指向虚函数表，来存储自己的虚函数地址。

**思考：为什么不将两个虚函数表进行合并呢？**

主要的原因在于虚拟继承时，派生类成员在前，基类成员在后。如果和从基类吸收过来的虚函数表进行合并，那么如果想要查找派生类虚函数的入口地址时，需要先借助于虚基指针，查找到虚基类所在的位置，然后再利用虚函数指针得到对应的虚函数位置。但是如果新增一个虚函数指针，此时只需要查找一次，便可以得到派生类虚函数的入口位置。

##### 5.带虚函数的菱形继承

```C++
class A {
public:
    virtual void printA() {
        cout << "A()" << endl;
    }
private:
    double _ia;
};
class B :virtual public A{
public:
    virtual void printB() {
        cout << "B()" << endl;
    }
private:
    double _ib;
};
class C:virtual public A{
public:
    virtual void printC() {
        cout << "C()" << endl;
    }
private:
    double _ic;
};
class DABC:public B ,public C {
public:
    virtual void printD() {
        cout << "D()" << endl;
    }
private:
    double _id;
};
```

<img src="C:\Users\34078\Pictures\Snipaste_2025-07-22_20-20-38.png" style="zoom:67%;" />

**思考：此时最低层的派生类为什么没有虚函数指针**

因为此时最底层的D类会将其虚函数的地址放入离它最近的虚函数表中。
