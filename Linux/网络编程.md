## 网络编程

大端存储法（网络字节序）：高位字节存储在内存的低地址端。

小端存储法（主机字节序）：低位字节存储在内存的低地址端。

#### 大小端转化

```C
uint32_t htonl(uint32_t hostlong);//小->大
uint16_t htons(uint16_t hostshort);//小->大
uint32_t ntohl(uint32_t netlong);//大->小
uint16_t ntohs(uint16_t netshort);//大->小
// uint32_t: 无符号 int
// uint16_t: 无符号 short int
```

#### sockaddr结构体

sockaddr结构体，是一种通用的地址结构，可以通用的描述IPv4和IPV6的结构，而且基本上所有涉及到地址的接口都使用了该类型作为参数。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250624153949606.png" alt="image-20250624153949606" style="zoom: 33%;" />

```C
struct sockaddr_in {
    sa_family_t    sin_family; // 地址类型: AF_INET (IPv4)
    in_port_t      sin_port;   // 端口号: 注意in_port_t实际类型short int   (网络字节序)
    struct in_addr sin_addr;   // IP地址:  internet address
};

struct in_addr {
    in_addr_t   s_addr;  // in_addr_t -> uint32_t -> 无符号int
}
```

点分十进制的IP地址字符串和网络字节序的转化

```C
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
// 将一个点分十进制的IP地址字符串  -> 转换为网络字节序的32位整型数表示。
in_addr_t inet_addr(const char *cp);
// 将一个点分十进制的IP地址字符串  -> 转换为网络字节序的32位整型数表示。
int inet_aton(const char *cp, struct in_addr *inp);
// 将网络地址  -> 转换为点分十进制IP地址的字符串形式。
char *inet_ntoa(struct in_addr in);
```

#### **基于TCP的Socket通信流程**

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250624191858752.png" alt="image-20250624191858752" style="zoom: 67%;" />

以下是客户端和服务端基于TCP通信的代码：

服务端：

```c
#include <header.h>

int main()
{
    char *port = "9000";
    char *ip = "0.0.0.0";//本机地址，客户端可以在远程连接服务器。
   
    int socket_fd = socket(AF_INET, SOCK_STREAM, 0);

    struct  sockaddr_in  sock;
    sock.sin_family = AF_INET;
    sock.sin_port = htons(atoi(port));
    sock.sin_addr.s_addr = inet_addr(ip);
  
    int ret = bind(socket_fd, (struct sockaddr *)&sock, sizeof(sock));
    ERROR_CHECK(ret, -1, "bind");
    listen(socket_fd, 10);
    printf("---- \n");
  

    struct sockaddr_in sock_client;
    socklen_t len = sizeof(sock_client);
    //int net_fd = accept(socket_fd, (struct sockaddr *)&sock, &len);
    int net_fd = accept(socket_fd, NULL, NULL);
    printf("****** \n");
    
    char buf[100] = {0};
    recv(net_fd, buf, sizeof(buf), 0);
    printf("buf: %s \n", buf);
    
    send(net_fd, "nihao", 5, 0);
    close(net_fd);
    close(socket_fd);
    return 0;
}


```

**Socket函数**

```C
int socket(
    int domain, // 协议:AF_INET (IPv4)、AF_INET6 (IPV6)....
    int type,   // 套接字类型: SOCK_STREAM (TCP)、SOCK_DGRAM (UDP)....
    int protocol// 协议:IPPROTO_TCP (TCP)、IPPTOTO_UDP (UDP)...; 当protocol为0时，会自动选择type类型对应的默认协议。
);
// 返回值:  返回值是一个非负整数, 代表一个文件描述符，用于标识创建的套接字，并通过这个描述符进行后续的网络I/O操作。
```

在内核中创建socket端点对象，在这个socket对象中有输入缓冲区和输出缓冲区。

输出缓冲区：当有数据要发送到网络上时，可以把用户态的数据拷贝到输出缓冲区（操作系统会选择合适的时机，把数据拷贝到网卡上，网卡把数据发送网络）

输入缓冲区：当网络数据到来时，操作系统收到一份数据（网卡接收交给操作系统），会检查数据给那个socket。比如操作系统会检查收到的数据信息，检查信息给那个端口，进一步把数据转给对应端口关联的socket对象，等待用户程序读取输入缓冲区。

socket执行结束的时候，还会把socket对象地址/引用/指针信息，放入文件描述符数组中。但是此时socket对象和端口无关

**bind函数**

```C
int bind(
    int sockfd,                 // socket端点文件描述符
    const struct sockaddr *addr,// 要绑定的IP地址和端口号，通用类型：Ipv4,IPv6类型的结构体->结构体强转
    socklen_t addrlen           // 指定的addr代表结构体长度,确保bind函数可以正确解析给定的地址信息:sizeod(addr)
);
//返回值: 成功时返回0。失败返回-1
```

Bind作用:给某个socket对象绑定端口和IP信息。

**注意**：bind绑定的是服务器的端口，用来让socket对象去监听这个端口，等待接收向这个端口发送的数据。

**注意**：bind绑定的IP地址也是服务器自己的。

**Listen函数**

```C
int listen(
    int sockfd,     // socket端点文件描述符
    int backlog     // 这个参数指定了套接字可以挂起的最大连接数，队列的长度
);
//返回值: 成功返回0, 失败返回-1
```

listen：要求socket对象放弃对输入输出缓冲区的持有，创建半连接队列和全连接队列，监听端口。

**半连接队列**：用于存储握手完成一半的信息（第一次握手和第二次握手）

**全连接队列**：存储三次握手已经完毕的信息。

**注意:**  可以使用 netstat -an 命令可以查看主机上某个端口的监听情况 (eg: netstat -an|grep 12345)。

**Accept函数**

```C
int accept(
    int sockfd,             // socket端点文件描述符
    struct sockaddr *addr,  // 用来获取连接对端/客户端的地址信息。如果不需要对端的地址信息, 可设参数为NULL
    socklen_t *addrlen      // 用来获取addr结构体的大小。如果使用addr/非NULL,那么addrlen必须设置addr的大小/sizeof(addr);  如果addr是NULL，addrlen也必须是NULL。
);
// 返回值: 成功则返回一个新的套接字文件描述符,用于与客户端通信。失败返回-1。
```

accept：从全连接队列中，获取已经三次握手完毕的信息，获取一个新的socket对象，把这个对象的引用存储在文件描述符数组中，获取文件描述符数组的下标。

> [!CAUTION]
>
> accept有可能阻塞，当全连接队列中无信息（没有客户端来进行三次握手），阻塞。当三次握手完毕时，全连接队列中有内容时，解除阻塞。
>
> 这个accept获得的新的socket对象，是专门用来服务这一个客户端的（从全连接队列中拿出握手信息的代表客户端）。

**send和recv**

```C
ssize_t send(
    int sockfd,         // socket端点文件描述符
    const void *buf,    // 指向要发送数据的缓冲区的指针
    size_t len,         // buf中数据的长度，以字节为单位
    int flags           // 用于指定发送操作的额外选项: MSG_OOB(发送紧急数据)、MSG_DONTROUTE(不经过路由器直接发送到本地网络上的目的地)...大多数情况下，flags参数设置为0。
);
// 返回值: 成功返回实际发送的字节数。失败返回-1
//send函数只是将用户的发送缓冲区中的数据拷贝到内核态的发送缓冲区，真正的发送操作是内核协议栈来完成的。
```

```C
ssize_t recv(
    int sockfd,     // socket端点文件描述符
    void *buf,      // 指向读出数据存放的缓冲区的指针
    size_t len,     // buf的长度，以字节为单位
    int flags       // 定接收行为的标志位:MSG_PEEK(查看数据但不从系统缓冲区中移除)、MSG_WAITALL(等待所有请求的数据才返回)...大多数情况下，flags设置为0。
);
// 返回值: 大于0,成功时返回实际读取的字节数。如果连接已经关闭返回0(对方close: 四次挥手)。读取失败返回-1
```

send和recv的本质其实就是write和read，但是send和recv是专门给收发网络数据用的，用来和socket进行交互。

注意：send和recv仅仅只是把数据从内核和输入输出缓冲区和用户态进行拷贝，数据什么时候到来，或者数据什么时候从输出缓冲区拷贝到网卡，send和recv决定不了，操作系统自行决定。

1. send和recv的次数和网络上传输的TCP数据段的数量没有关系，多次的send和recv可能只需要一次TCP段的传输。

2. 另外一方面， TCP是一种流式的通信协议，消息是以字节流的方式在信道中传输，这就意味着一个重要的事情， 消息和消息之间是没有边界的。

3. 在不加额外约定的情况下，通信双方并不知道发送和接收到底有没有接收完一个消息，有可能多个消息会在一次传输中被发送和接收（江湖俗称"粘包"），也有有可能一个消息需要多个传输才能被完整的发送和接收(江湖俗称"半包")。

   

**close函数**

```C
int close(
    int fd  // socket端点文件描述符
);
// 返回值: 关闭成功返回0, 失败返回-1
```

客户端或者服务器使用close函数关闭连接的时候,  可能还有数据留在发送缓冲区中未被发送, close操作会试图发送这些数据。

close函数给连接的对端发送FIN包用于断开连接的四次挥手,  等待连接的另一端也发送FIN包，并且本端回应ACK确认关闭。

释放端口等资源。

客户端代码如下：

```C
#include <header.h>

int main(int argc, char *argv[argc]){

    char *port = "9000";
    //char *ip = "47.115.220.165";
    char *ip = "192.168.106.130";

    int socket_fd = socket(AF_INET, SOCK_STREAM, 0);

    struct sockaddr_in  sock;
    sock.sin_family = AF_INET;
    sock.sin_port = htons(atoi(port));
    sock.sin_addr.s_addr = inet_addr(ip);

    int ret = connect(socket_fd, (struct sockaddr *)&sock, sizeof(sock));
    ERROR_CHECK(ret, -1, "connect");
    while(1){
    }
    send(socket_fd, "zaima", 5, 0);
    char buf[100] = {0};
    recv(socket_fd, buf, sizeof(buf), 0);
    printf("buf: %s \n", buf);
    close(socket_fd);
    return 0;
}

```

**Connect函数**

```C
int connect(
    int sockfd,                 // socket端点文件描述符
    const struct sockaddr *addr,// 目标服务器的地址和端口信息，用于向这个服务器发起三次握手
    socklen_t addrlen           // 指定的addr代表结构体长度,确保bind函数可以正确解析给定的地址信息
);
// 返回值: 成功0, 失败-1
```

Connect：用于客户端向服务端发送一个建立连接的请求，初始化连接

客户端在调用connect可以不使用bind来指定本地的端口信息，这客户端就会随机选择一个临时端口号来作为源端口。

调用connect预期是完成TCP建立连接的三次握手。 如果服务端未开启对应的端口号或者未监听，则只能收到一个RST回复，并且报错返回的内容 是"Connection refused"。

**复用网络地址**

```c++
int on=1;
int ret=setsocketpt(listenfd,SOL_SOCKET,SO_REUSEADDR,&on,sizeof(on));
if(ret<0){
    perror("setsocket");
    close(listenfd);
    retrun EXIT_FAILURE;
}
```

### I/O多路复用模型

I/O多路复用是一种同步的I/O模型，实现一个线程可以监听多个文件描述符上发生的事件。

一旦某个文件描述符就绪，就能通知用户态进行相应的读写操作。

没有文件描述符就绪时，会阻塞用户态程序，交出CPU。

<font color='red'>**复用**</font>是指一个线程处理多个文件描述符（多个连接）。

常见I/O多路复用模型有select/poll/epoll。

#### epoll

epoll相当于一个监工，可以监听文件描述符上发生的事件。

**epoll_create1**

```c++
int epoll_create(int flags);
```

返回值是一个epoll的实例（假如是epfd），是一个文件描述符。

**红黑树的特点：**

- 1.节点不是红色就是黑色
- 2.根节点是黑色的
- 3.叶子节点是黑色
- 4.不能有连续的两个节点是红色
- 5.从根节点到任意一个叶子节点上的黑色数目相同。
- 6.不是一颗平衡二叉树。
- 查找节点的平均时间复杂度为O(log2n),类似于二分查找，每一次可以删除一半的元素。

![image-20250829175157934](C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250829175157934.png)

**epoll_ctl**

```c++
int epoll_ctl(int epfo,int op ,int fd,struct epoll_event *event);
```

作用：控制红黑树，对红黑树进行增删查改。

op：

EPOLL_CTL_ADD   添加

EPOLL_CTL_MOD  修改

EPOLL_CTL_DEL     删除

将整型数据中的某一个位置设为1，就代表该事件发生了。

EPOLLIN 读事件

EPOLLOUT  写事件

EPOLLET     边缘触发

##### **epoll_wait**

```c++

```

