# TCP

传输控制协议（TCP）是工作在传输层，目标是在不可靠的逐跳传输的网络层之上，构建一个可靠的 、面向连接的 、全双工的端到端协议。

#### TCP报文头部

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250623214037007.png" alt="image-20250623214037007" style="zoom: 67%;" />

**源端口**：发送请求的主机的发送端口

**目的端口**：目标主机接收的请求端口

**序号Seq**：本报文段所发送的数据的第一个字节的编号。比如某一报文段的序号Seq值是301，它携带的数据共有100个字节，则表明报文段的数据的第一个字节序号编号为301，最后一个字节的序号为400； 那么下一个报文段的序号Seq值就是401。

**确认号Ack**：确认号是我们接收到一个请求之后，并且经过对数据检测给对方表示确认这个数据合法的标识。例如主机A向主机B发送了一个报文段，此次报文段序号Seq为185，携带数据50字节。主机B收到这个报文段后给A回复的确认报文中，确认位ACK为1， 确认号Ack位235（=185+50）， 表示B已经收到了字节编号为185~234的正确数据， 期望收到A的标号为235的数据。

**数据偏移**:表示TCP报文段的数据起始处（即：TCP首部后面的应用层数据起始位置）距TCP报文段的起始处有多远，即TCP首部长度。

**保留位**：保留为今后使用，目前置为0。

**紧急位URG**：占用1位， URG=1表示后面的紧急指针有效（它告诉系统报文段有紧急数据，告诉目标主机应当尽快处理）（当接收端的TCP层检测到一个设置了URG位的报文段，它会立即将这部分数据传递给上层的应用程序，而不是按照正常的队列顺序排队。这使得应用程序能够快速响应紧急情况），URG=0表示后面的紧急指针无效。

**确认位ACK**：占用1位， ACK=1表示前面确认位有效，ACK=0表示前面确认位无效。

**推送位PSH**：占用1位， 当一台主机接收到PSH=1的报文段，表示应尽快交付给接收该请求的应用进程，而不是等到整个缓存都存满之后再向上交付。

**复位位RSH**：占用1位， 当RSH=1表示TCP链接中出现严重差错（eg：主机崩溃），必须释放链接，然后进行重建连接

**同步位SYN**：占用1位， 当SYN=1表示这是一个建立连接的请求（eg：SYN=1，ACK=0请求连接第一次握手， SYN=1，ACK=1响应连接请求第二次握手）

**终止位FIN**：占用1位， 当FIN=1用来释放一个连接，表明此报文段发送方的数据已经发送完毕，并要求释放运输连接（第1和3次挥手）

**窗口大小**：表示发送端的接收窗口所能允许接受到对方发送的数据量的大小。

**效验和**：检验的范围包括首部和数据部分。

**紧急指针**：紧急指针仅指在URG=1时才有意义，它指出本报文段中紧急数据的字节数。当所有紧急数据都处理完毕，TCP就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为0也可以发送紧急数据。

**选项可变长度**：0~40字节，最常见的选项是最大 段大小（MSS）, 用来描述后续希望接收到的报文段的最大值，(这个数值通常受限于(数据帧)MTU，比如MTU为1500，IP数据报头部为20字节， TCP头部为20字节，则MSS是1460)。

#### TCP三次握手

TCP采用三次握手的目的是，确保双方的接收和发送能力没有问题，并同步初始序列号。

举个例子：

A：喂，听得到吗？

B：听得到，你听得到吗？

A：听得到。

##### **TCP三次握手的建立过程**

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250623215717494.png" alt="image-20250623215717494" style="zoom:67%;" />

最开始的时候客户端和服务器都是处于CLOSED关闭状态。主动打开连接的为客户端，被动打开连接的是服务器。

TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 LISTEN 监听状态

第一次握手 TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这时报文首部中的同步位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT 同步已发送状态

第二次握手 TCP服务器收到请求报文后，如果同意连接，则会向客户端发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了 SYN-RCVD 同步收到状态

第三次握手 TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED已建立连接状态 触发三次握手

##### **为什么采用三次连接而不采用两次连接？**

TCP三次握手可以确保双方的发送和接受能力都是正常的，而且可以同步双方的初始序列号。

如果采用两次握手的话，只能确认客户端的发送能力正常，以及服务器的发送能力和接受能力正常，而无法得知客户端的接受能力是否正常。如果采用两次握手时，客户端的接受能力不正常，服务器给客户端发送数据，而客户端无法接受，就会导致资源的浪费。

此外如果采用两次握手，将无法实现初始序列号的同步。若采用两次握手，将无法确认对方的序列号接受状态，假设客户端给服务端发送的序号为100的报文段，因为网络问题丢失了，然后超时重传了一个序列号为200的报文段，服务端接收到后发送了一个确认号为201的确认报文,而客户端不知道序号为100的报文段丢失，客户端假设服务器接收到了100这个SYN,因此客户端后续都会基于100这个序列号发送数据，而服务端期望的是200这个序列号之后的数据，此时就导致了双方的序列号不同步，服务端会丢弃客户端发送的数据。

此外采用两次握手还会导致历史连接问题，当客户端向服务端发送一个TCP请求，因为网络问题丢失了，而后因为超时，客户端重发了这个请求，当服务端收到时，会认为这是一个新的连接请求，然后建立请求，等待对方传输数据，而对方又不会传输数据，造成资源浪费。

#### TCP四次挥手

##### TCP四次挥手的连接过程

举个例子：

张三和李四对话

张三：我先走了

李四：好的，那你走吧

李四：那我也走了？

张三：好的，你走吧。

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250623221858111.png" alt="image-20250623221858111" style="zoom:67%;" />

数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。

第一次挥手 客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态

第二次挥手 服务器端接收到连接释放报文后，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT 关闭等待状态

第三次挥手 客户端接收到服务器端的确认请求后，客户端就会进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

第四次挥手 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态，但此时TCP连接还未终止，必须要经过2MSL后（最长报文寿命），当客户端撤销相应的TCB后，客户端才会进入CLOSED关闭状态，服务器端接收到确认报文后，会立即进入CLOSED关闭状态，到这里TCP连接就断开了，四次挥手完成

##### 为什么客户端要等待2MSL？

主要原因是为了保证客户端发送那个的第一个ACK报文能到服务器，因为这个ACK报文可能丢失，并且2MSL是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，这样新的连接中不会出现旧连接的请求报文。

防止旧连接的数据包干扰新连接。当客户端和服务端关闭后，又立刻重新进行连接，且端口和旧连接一样。若服务器端有滞留数据因为网络延迟到达客户端，客户端可能会认为这是新数据，导致数据错乱。

##### 为什么采用四次挥手而不采用三次挥手？

由于TCP的传输是全双工的，这就意味这每个方向的通道关闭都需单独进行，此外采用四次挥手可以确保数据传输的完整性。

若采用三次挥手时，第一次挥手，客户端向服务端发送关闭请求FIN，第二次挥手，服务器收到客户端的关闭请求，回复一个ACK并携带FIN，此时服务器会立即停止发送数据。第三次挥手，客户端收到服务端的FIN,回复一个ACK,关闭连接。此时由于提前关闭，可能会存在剩余的数据没有发送出去，导致数据传输的不完整性。

#### TCP的状态转换

<img src="C:\Users\34078\AppData\Roaming\Typora\typora-user-images\image-20250623222659767.png" alt="image-20250623222659767" style="zoom:67%;" />

#### 为什么连接的时候是三次握手，关闭的时候却是四次握手？

建立连接时因为当服务端收到客户端的SYN连接请求报文后，可以直接发送**SYN+ACK**报文。其中ACK报文是用来应答的，SYN报文是用来同步的。所以建立连接只需要三次握手。

由于TCP协议是一种面向连接的、可靠的、基于字节流的传输层通信协议，TCP是**全双工模式**。这就意味着，关闭连接时，当客户端发出FIN报文段时，只是表示客户端告诉服务端数据已经发送完毕了。当服务端收到FIN报文并返回ACK报文段，表示它已经知道客户端没有数据发送了，但是服务端还是可以发送数据到客户端的，所以S服务很可能并不会立即关闭连接，直到服务端把数据也发送完毕。当服务端也发送了FIN报文段时，这个时候就表示服务端也没有数据要发送了，就会告诉客户端，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。